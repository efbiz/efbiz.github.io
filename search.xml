<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 8 中的 Streams API 详解]]></title>
    <url>%2F2017%2F09%2F19%2FJava8-%E4%B8%AD%E7%9A%84Streams%20API%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[为什么需要 StreamStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。 什么是聚合操作在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如： 客户每月平均消费金额最昂贵的在售商品本周完成的有效订单（排除了无效的）取十个数据样本作为首页推荐 这类的操作。但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：清单 1. Java 7 的排序、取值实现 List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;(); for(Transaction t: transactions){ if(t.getType() == Transaction.GROCERY){ groceryTransactions.add(t); } } Collections.sort(groceryTransactions, new Comparator(){ public int compare(Transaction t1, Transaction t2){ return t2.getValue().compareTo(t1.getValue()); } }); List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;(); for(Transaction t: groceryTransactions){ transactionsIds.add(t.getId()); } 而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。清单 2. Java 8 的排序、取值实现 List&lt;Integer&gt; transactionsIds = transactions.parallelStream(). filter(t -&gt; t.getType() == Transaction.GROCERY). sorted(comparing(Transaction::getValue).reversed()). map(Transaction::getId). collect(toList()); Stream 总览什么是流Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下： 1.0-1.4 中的 java.lang.Thread5.0 中的 java.util.concurrent6.0 中的 Phasers 等7.0 中的 Fork/Join 框架8.0 中的 Lambda Stream 的另外一大特点是，数据源本身可以是无限的。 流的构成当我们使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。图 1. 流管道 (Stream Pipeline) 的构成 有多种方式生成 Stream Source：从 Collection 和数组 Collection.stream() Collection.parallelStream() Arrays.stream(T array) or Stream.of() 从 BufferedReader java.io.BufferedReader.lines() 静态工厂 java.util.stream.IntStream.range() java.nio.file.Files.walk() 自己构建 java.util.Spliterator 其它 Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 流的操作类型分为两种：Intermediate 一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 Terminal 一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。还有一种操作被称为short-circuiting用以指 对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。 清单 3. 一个流操作的示例 int sum = widgets.stream() .filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum(); stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。 流的使用详解简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 流的构造与转换下面提供最常见的几种构造 Stream 的样例。 构造流的几种常见方法// 1. Individual values Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); // 2. Arrays String [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; stream = Stream.of(strArray); stream = Arrays.stream(strArray); // 3. Collections List&lt;String&gt; list = Arrays.asList(strArray); stream = list.stream(); 需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：IntStream、LongStream、DoubleStream。当然我们也可以用 Stream、Stream &gt;、Stream，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。 数值流的构造IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println); IntStream.range(1, 3).forEach(System.out::println); IntStream.rangeClosed(1, 3).forEach(System.out::println); 流转换为其它数据结构// 1. Array String[] strArray1 = stream.toArray(String[]::new); // 2. Collection List&lt;String&gt; list1 = stream.collect(Collectors.toList()); List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new)); Set set1 = stream.collect(Collectors.toSet()); Stack stack1 = stream.collect(Collectors.toCollection(Stack::new)); // 3. String String str = stream.collect(Collectors.joining()).toString(); 一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。 流的操作接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。 Intermediate map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered Terminal forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator Short-circuiting anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 我们下面看一下 Stream 的比较典型用法。 map/flatMap我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。转换大写 List&lt;String&gt; output = wordList.stream(). map(String::toUpperCase). collect(Collectors.toList()); 这段代码把所有的单词转换为大写。 平方数 List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4); List&lt;Integer&gt; squareNums = nums.stream(). map(n -&gt; n * n). collect(Collectors.toList()); 这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。一对多 Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) ); Stream&lt;Integer&gt; outputStream = inputStream. flatMap((childList) -&gt; childList.stream()); flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。 filterfilter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。留下偶数 Integer[] sixNums = {1, 2, 3, 4, 5, 6}; Integer[] evens = Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new); 经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。把单词挑出来 List&lt;String&gt; output = reader.lines(). flatMap(line -&gt; Stream.of(line.split(REGEXP))). filter(word -&gt; word.length() &gt; 0). collect(Collectors.toList()); 这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。 forEachforEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。打印姓名（forEach 和 pre-java8 的对比） // Java 8 roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName())); // Pre-Java 8 for (Person p : roster) { if (p.getGender() == Person.Sex.MALE) { System.out.println(p.getName()); } } 对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的： stream.forEach(element -&gt; doOneThing(element)); stream.forEach(element -&gt; doAnotherThing(element)); 相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。 peek 对每个元素执行操作并返回一个新的 Stream Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e)) .collect(Collectors.toList()); forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 findFirst这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。 Optional 的两个用例 String strA = &quot; abcd &quot;, strB = null; print(strA); print(&quot;&quot;); print(strB); getLength(strA); getLength(&quot;&quot;); getLength(strB); public static void print(String text) { // Java 8 Optional.ofNullable(text).ifPresent(System.out::println); // Pre-Java 8 if (text != null) { System.out.println(text); } } public static int getLength(String text) { // Java 8 return Optional.ofNullable(text).map(String::length).orElse(-1); // Pre-Java 8 // return if (text != null) ? text.length() : -1; }; 在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。 reduce这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于 Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或 Integer sum = integers.reduce(0, Integer::sum); 也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。 reduce 的用例 // 字符串连接，concat = &quot;ABCD&quot; String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); // 求最小值，minValue = -3.0 double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值 int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum); // 求和，sumValue = 10, 无起始值 sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get(); // 过滤，字符串连接，concat = &quot;ace&quot; concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat); 上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。 limit/skiplimit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。limit 和 skip 对运行次数的影响 public void testLimitAndSkip() { List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 10000; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); } List&lt;String&gt; personList2 = persons.stream(). map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); System.out.println(personList2); } private class Person { public int no; private String name; public Person (int no, String name) { this.no = no; this.name = name; } public String getName() { System.out.println(name); return name; } } 输出结果为： name1name2name3name4name5name6name7name8name9name10[name4, name5, name6, name7, name8, name9, name10] 这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。 limit 和 skip 对 sorted 后的运行次数无影响 List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); } List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList()); System.out.println(personList2); 上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为： name2name1name3name2name4name3name5name4[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27] 即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。 sorted对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：清单 18. 优化：排序前进行 limit 和 skip List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); } List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList()); System.out.println(personList2); 结果会简单很多： name2name1[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a] 当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。 min/max/distinctmin 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。找出最长一行的长度 BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;)); int longest = br.lines(). mapToInt(String::length). max(). getAsInt(); br.close(); System.out.println(longest); 下面的例子则使用 distinct 来找出不重复的单词。找出全文的单词，转小写，并排序 List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList()); br.close(); System.out.println(words); MatchStream 有三个 match 方法，从语义上说：allMatch：Stream 中全部元素符合传入的 predicate，返回 trueanyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 truenoneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。使用 Match List&lt;Person&gt; persons = new ArrayList(); persons.add(new Person(1, &quot;name&quot; + 1, 10)); persons.add(new Person(2, &quot;name&quot; + 2, 21)); persons.add(new Person(3, &quot;name&quot; + 3, 34)); persons.add(new Person(4, &quot;name&quot; + 4, 6)); persons.add(new Person(5, &quot;name&quot; + 5, 55)); boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18); System.out.println(&quot;All are adult? &quot; + isAllAdult); boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12); System.out.println(&quot;Any child? &quot; + isThereAnyChild); 输出结果： All are adult? falseAny child? true 进阶：自己生成流Stream.generate通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。生成 10 个随机整数 Random seed = new Random(); Supplier&lt;Integer&gt; random = seed::nextInt; Stream.generate(random).limit(10).forEach(System.out::println); //Another way IntStream.generate(() -&gt; (int) (System.nanoTime() % 100)). limit(10).forEach(System.out::println); Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。 自实现 Supplier Stream.generate(new PersonSupplier()). limit(10). forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge())); private class PersonSupplier implements Supplier&lt;Person&gt; { private int index = 0; private Random random = new Random(); @Override public Person get() { return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100)); } } 输出结果： StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76 ##Stream.iterateiterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。24. 生成一个等差数列 Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));. 输出结果： 10 3 6 9 12 15 18 21 24 27 与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。 进阶：用 Collectors 来进行 reduction 操作java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。groupingBy/partitioningBy按照年龄归组 Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge)); Iterator it = personGroups.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size()); } 上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出： Age 0 = 2Age 1 = 2Age 5 = 2Age 8 = 1Age 9 = 1Age 11 = 2…… 按照未成年人和成年人归组 Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18)); System.out.println(&quot;Children number: &quot; + children.get(true).size()); System.out.println(&quot;Adult number: &quot; + children.get(false).size()); 输出结果： Children number: 23Adult number: 77 在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。 #结束语总之，Stream 的特性可以归纳为： 不是数据结构 它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。 它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 所有 Stream 的操作必须以 lambda 表达式为参数 不支持索引访问你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。很容易生成数组或者 List 惰性化很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。 并行能力当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 可以是无限的集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。]]></content>
      <categories>
        <category>java</category>
        <category>java8</category>
      </categories>
      <tags>
        <tag>Java8 Streams java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 日期/时间（Date Time）API指南]]></title>
    <url>%2F2017%2F09%2F19%2FJava8-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%EF%BC%88Date-Time%EF%BC%89API%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[为什么我们需要新的Java日期/时间API？在开始研究Java 8日期/时间API之前，让我们先来看一下为什么我们需要这样一个新的API。在Java中，现有的与日期和时间相关的类存在诸多问题，其中有：1、Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。2、java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。3、对于时间、时间戳、格式化以及解析，并没有一些明确定义的类。对于格式化和解析的需求，我们有java.text.DateFormat抽象类，但通常情况下，SimpleDateFormat类被用于此类需求。4、所有的日期类都是可变的，因此他们都不是线程安全的，这是Java日期类最大的问题之一。5、日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。在现有的日期和日历类中定义的方法还存在一些其他的问题，但以上问题已经很清晰地表明：Java需要一个健壮的日期/时间类。这也是为什么Joda Time在Java日期/时间需求中扮演了高质量替换的重要角色。 Java 8日期/时间API设计原则1、不变性：新的日期/时间API中，所有的类都是不可变的，这对多线程环境有好处。2、关注点分离：新的API将人可读的日期时间和机器时间（unix timestamp）明确分离，它为日期（Date）、时间（Time）、日期时间（DateTime）、时间戳（unix timestamp）以及时区定义了不同的类。3、清晰：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用now()方法，在所有的类中都定义了format()和parse()方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。4、实用操作：所有新的日期/时间API类都实现了一系列方法用以完成通用的任务，如：加、减、格式化、解析、从日期/时间中提取单独部分，等等。5、可扩展性：新的日期/时间API是工作在ISO-8601日历系统上的，但我们也可以将其应用在非IOS的日历上。 Java日期/时间API包Java日期/时间API包含以下相应的包。1、java.time包：这是新的Java日期/时间API的基础包，所有的主要基础类都是这个包的一部分，如：LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration等等。所有这些类都是不可变的和线程安全的，在绝大多数情况下，这些类能够有效地处理一些公共的需求。2、java.time.chrono包：这个包为非ISO的日历系统定义了一些泛化的API，我们可以扩展AbstractChronology类来创建自己的日历系统。3、java.time.format包：这个包包含能够格式化和解析日期时间对象的类，在绝大多数情况下，我们不应该直接使用它们，因为java.time包中相应的类已经提供了格式化和解析的方法。4、java.time.temporal包：这个包包含一些时态对象，我们可以用其找出关于日期/时间对象的某个特定日期或时间，比如说，可以找到某月的第一天或最后一天。你可以非常容易地认出这些方法，因为它们都具有“withXXX”的格式。5、java.time.zone包：这个包包含支持不同时区以及相关规则的类。 Java日期/时间API示例如何在java8中获取当天的日期java8中有个叫LocalDate的类，能用来表示今天的日期。这个类与java.util.Date略有不同，因为它只包含日期，没有时间。 LocalDate today = LocalDate.now(); -- 2017-09-19 如何在java8中获取当前的年月日LocalDate类中提供了一些很方便的方法可以用来提取年月日以及其他的日期属性,特别方便，只需要使用对应的getter方法就可以了，非常直观。 LocalDate today = LocalDate.now(); int year = today.getYear(); int month = today.getMonthValue(); int day = today.getDayOfMonth(); System.out.println(year); System.out.println(month); System.out.println(day); 在java8中如何获取某个特定的日期通过另一个方法，可以创建出任意一个日期，它接受年月日的参数，然后返回一个等价的LocalDate实例。在这个方法里，需要的日期你填写什么就是什么，不想之前的API中月份必须从0开始。 LocalDate birthDay = LocalDate.of(2001, 1, 1); System.out.println(birthDay); 在java8中检查两个日期是否相等LocalDate重写了equals方法来进行日期的比较。 LocalDate todayEq = LocalDate.of(2017,9,19); System.out.println(todayEq.equals(today)); 在java8中如何检查重复事件，比如生日在java中还有一个与时间日期相关的任务就是检查重复事件，比如每月的账单日如何在java中判断是否是某个节日或者重复事件，使用MonthDay类。这个类由月日组合，不包含年信息，可以用来代表每年重复出现的一些日期或其他组合。他和新的日期库中的其他类一样也都是不可变且线程安全的，并且它还是一个值类（value class）。 MonthDay birth_Day = MonthDay.of(9,19); MonthDay to_Day = MonthDay.from(today); if(birth_Day.equals(to_Day)) { System.out.println(&quot;今天是你的生日&quot;); }else { System.out.println(&quot;今天不是你的生日&quot;); } 如何在java8中获取当前时间这个与第一个例子获取当前日期非常相似，这里用的是LocalTime类，默认的格式是hh:mm:ss:nnn LocalTime now = LocalTime.now(); System.out.println(now); --- 17:42:53.966 如何增加时间里面的小时数很多时候需要对时间进行操作，比如加一个小时来计算之后的时间，java8提供了更方便的方法 如plusHours，这些方法返回的是一个新的LocalTime实例的引用，因为LocalTime是不可变的。 LocalTime now = LocalTime.now(); System.out.println(&quot;当前时间：&quot; + now); LocalTime two = now.plusHours(2); System.out.println(&quot;2小时后的时间：&quot; + two); --- 当前时间：17:45:12.091 2小时后的时间：19:45:12.091 在java8中使用时钟java8自带了Clock类，可以用来获取某个时区下（所以对时区是敏感的）当前的瞬时时间、日期。用来代替System.currentTimelnMillis()与TimeZone.getDefault()方法。 Clock clock = Clock.systemUTC(); System.out.println(clock); -- SystemClock[Z] 在java中如何判断某个日期在另一个日期的前面还是后面如何判断某个日期在另一个日期的前面还是后面或者相等，在java8中，LocalDate类中使用isBefore()、isAfter()、equals()方法来比较两个日期。如果调用方法的那个日期比给定的日期要早的话，isBefore()方法会返回true。equals()方法在前面的例子中已经说明了。 LocalTime now = LocalTime.now(); System.out.println(&quot;当前时间：&quot; + now); LocalTime two = now.plusHours(2); System.out.println(&quot;2小时后的时间：&quot; + two); System.out.println(now.isBefore(two)); --- 当前时间：17:49:21.295 2小时后的时间：19:49:21.295 true 在java8中处理不同的时区java8中不仅将日期和时间进行了分离，同时还有时区。比如ZonId代表的是某个特定时区，ZonedDateTime代表带时区的时间，等同于以前的GregorianCalendar类。使用该类，可以将本地时间转换成另一个时区中的对应时间。 LocalDateTime localDateTime = LocalDateTime.now(); ZoneId zone = ZoneId.of(ZoneId.SHORT_IDS.get(&quot;ACT&quot;)); ZonedDateTime zdt = ZonedDateTime.of(localDateTime, zone); System.out.println(&quot;特定时区时间为：&quot; + zdt); --- 特定时区时间为：2017-09-19T17:59:10.288+09:30[Australia/Darwin] 如何表示固定的日期，比如信用卡过期时间正如MonthDay表示的是某个重复出现的日子，YearMonth是另外一个组合，代表的是像信用卡还款日，定期存款到期日，options到期日这类的日期。你可以用这个类找出这个月有多少天，LengthOfMonth()这个方法返回的是这个YearMonth实例有多少天，这对于检查2月是否润2月很有用。 YearMonth currentYearMonth = YearMonth.now(); System.out.printf(&quot;这个月的是%s有%d天&quot;,currentYearMonth,currentYearMonth.lengthOfMonth()); System.out.println( &quot;currentYearMonth.atEndOfMonth()：&quot; + currentYearMonth.atEndOfMonth()); YearMonth creditCartExpiry = YearMonth.of(2018, Month.OCTOBER); System.out.printf(&quot;你选择的年月日期是%s %n &quot;,creditCartExpiry); --- 这个月的是2017-09有30天 currentYearMonth.atEndOfMonth()：2017-09-30 你选择的年月日期是2018-10 如何在java8中检查闰年LocalDate类由一个isLeapYear()方法来返回当前LocalDate对应的那年是否是闰年。 LocalDate today = LocalDate.now(); System.out.println(today.isLeapYear()); --- false 计算两个日期之间包含多少天，多少月计算两个日期之间包含多少天、周、月、年。可以用java.time.Period类完成该功能。下面例子中将计算日期与将来的日期之间一共有几个月。 LocalDate today = LocalDate.now(); LocalDate date1 = LocalDate.of(2017, Month.JULY, 12); Period period= Period.between(today, date1); System.out.println(period.getDays()); System.out.println(period.getMonths()); --- -7 -2 在java8中获取当前时间戳java8获取时间戳特别简单。Instant类由一个静态的工厂方法now()可以返回当前时间戳 Instant it = Instant.now(); System.out.println(it); 可以看到，当前时间戳是包含日期和时间的，与java.util.Date很类似，事实上Instant就是java8以前的Date，可以使用这个两个类中的方法在这两个类型之间进行转换，比如Date.from(Instant)就是用来把Instant转换成java.util.date的，而Date。toInstant()就是将Date转换成Instant的 如何在java8中使用预定义的格式器来对日期进行解析/格式化在java8之前，时间日期的格式化非常麻烦，经常使用SimpleDateFormat来进行格式化，但是SimpleDateFormat并不是线程安全的。在java8中，引入了一个全新的线程安全的日期与时间格式器。并且预定义好了格式。比如，本例中使用的BASICISODATE格式会将20160414格式化成2016-04-14 String day = &quot;20130923&quot;; LocalDate formatterd = LocalDate.parse(day, DateTimeFormatter.BASIC_ISO_DATE); System.out.println(formatterd); --- 2013-09-23 如何在java中使用自定义的格式器来解析日期 在上例中，我们使用了预置的时间日期格式器来解析日期字符串了，但是有时预置的不能满足的时候就需要我们自定义日期格式器了，下面的例子中的日期格式是”MM dd yyyy”.你可以给DateTimeFormatter的ofPattern静态方法()传入任何的模式，它会返回一个实例，这个模式的字面量与前例中是相同的。比如M代表月，m仍代表分，无效的模式会抛异常DateTimeParseException。 String day1 = &quot;2013 09 23&quot;; try { DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;); LocalDate holiday = LocalDate.parse(day1,df); System.out.println(holiday); } catch (DateTimeParseException e) { // TODO: handle exception } --- 2013-09-23 如何在java8中对日期进行格式化，转换成字符串 前面的两个例子中，我们主要是对日期字符串来进行解析转换成日期，在这个例子我们相反，是把日期转换成字符。这里我们有个LocalDateTime类的实例，我们要把他转换成一个格式化好的日期串，与前例相同的是，我们仍需要制定模式串去创建一个DateTimeFormatter类的实例，但调用的是LocalDate.format()。这个方法会返回一个代表当前日期的字符串，对应的模式就是传入的DateTimeFormatter实例中定义好的。 LocalDateTime aDate = LocalDateTime.now(); try { DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;); System.out.println(aDate.format(df)); } catch (Exception e) { // TODO: handle exception } --- 2017 09 19]]></content>
      <categories>
        <category>java</category>
        <category>java8</category>
      </categories>
      <tags>
        <tag>Java8 日期/时间工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻松学习新代码库的六个步骤]]></title>
    <url>%2F2017%2F09%2F09%2F%E8%BD%BB%E6%9D%BE%E5%AD%A6%E4%B9%A0%E6%96%B0%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E5%85%AD%E4%B8%AA%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[学习新的代码库是一项艰巨的任务。如果你不能和创建该库的研发人员进行交流，自己研究该库是一个很复杂的过程。本文给出六个步骤指引开发者学习。 步骤一：创建业务词汇表单如果你是一位开发者，你或许会出席过一些软件设计会议，会议可能会涉及到创建新术语，以便于更好的软件设计交流。在创建该术语的同时可能会发生与该术语同义的情况，会议成员不可避免地讨论这些具有相同概念的术语，这会让人感到混乱。 这时，业务词汇表单就变得尤为重要，它能记录这些新的术语。在软件设计的每个阶段，你会不断碰到新的术语和概念。把这些术语保存起来非常重要，并且边学边存储，绝对有益无害。 业务词汇表单应该包含几个不同的列，分别是：“术语名称”、“语境”、“定义”。当你看到一个有趣的术语和短语时，可以更新该表单。该表单有可能包含大量的同义词，也有可能有对同一术语的不同定义解释。出现上述的情况，你需要结合上下文的语境进行分析使用。 步骤二：了解应用程序运行应用程序并且获知该程序提供的功能。如果你不知道该程序是做什么的，就无法在源代码中寻找有关信息。 步骤三：浏览有效的类库文档迄今为止，是不是任何的体系结构或设计类库文档的内容都是合理呢？这有待考量。类库文档是一个极好的资源。如果旧的体系架构已经历了数次修订，它就不再值得你花时间去阅读整个文档，不过，你可以大概浏览一下。如果你足够幸运，你可以在文档中遇到你所需的术语。 步骤四：做假设几乎所有的应用程序中，开发者都会碰到如下情况：环境的配置、I18N（语言的国际化）、应用程序的文件格式、用户界面、应用程序的启动和关闭。针对这些情况，可以进行假设。开发者可以假设应用程序中的任何一段代码块，哪个代码块是应用程序的核心，这个才是学习的重点。 步骤 五：定位第三方库文件代码库很有可能存在一些的依赖。如果检查到项目中包含第三方库文件，可以查看该库文件是如何与应用程序的功能联系起来的，某处的模块或组件是如何使用第三方库的。 步骤六：分析代码本部分列举几个选项来分析新的代码库： 1、目录以及文件架构可以把目录名中的一些术语添加到业务词汇表单中。文件架构可以提供一些基本的线索，如：前台代码及后台代码。它们可以分别放在独立的文件中。开发者会发现，凡具有特定功能的模块代码都被放在独立的文件夹中。按照这个线索，就知道如何进行查找了。 2、功能文件的映射在用户界面上写一些可执行的功能代码块。把重要的代码块放到一个单独的文件夹中，并对文件夹进行命名。这个文件夹有可能对团队中的其他人有用，他们可以把该功能应用到项目编程中。 3、单元测试如果采用单元测试，开发者可能会用到第三方框架。你可以用第三方框架来辅助测试。即使没有找到合适的框架，仍然可以来做单元测试。当然，你也可以不采用单元测试，但我依然推荐你用，因为有助于你对源代码中组件的理解。 4、注释源代码中可能包含一些注释，有的注释对开发人员很有帮助，有的会让人有所误导或有的注释可能过期了。如果你觉得注释有问题，你可以通过调试器追踪有关代码，了解相关代码的意思。如果你发现错误的注释，修改或删除它们。 5、可视化工具在新的代码库中使用语言代码分析工具。如：ObjectAid是一个极好的Java代码分析工具。这是 Eclipse IDE中的一个插件。你可以创建对象来协助类图，把java文件拉到类图中，就自动画出类图。 6、设置断点使用调试器，设置一些断点并运行查看。这是第一次学习新的代码基础。 结论上述的分析过程采用自上而下的方法，能够更好的帮助开发者学习新的代码库。]]></content>
      <tags>
        <tag>源码学习 架构师之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式定时任务调度系统技术选型]]></title>
    <url>%2F2017%2F08%2F15%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[我们先思考下面几个业务场景的解决方案: 支付系统每天凌晨1点跑批，进行一天清算，每月1号进行上个月清算 电商整点抢购，商品价格8点整开始优惠 12306购票系统，超过30分钟没有成功支付订单的，进行回收处理 商品成功发货后，需要向客户发送短信提醒 类似的业务场景非常多，我们怎么解决？ 为什么我们需要定时任务很多业务场景需要我们某一特定的时刻去做某件任务，定时任务解决的就是这种业务场景。一般来说，系统可以使用消息传递代替部分定时任务，两者有很多相似之处，可以相互替换场景。如，上面发货成功发短信通知客户的业务场景，我们可以在发货成功后发送MQ消息到队列，然后去消费mq消息，发送短信。但在某些场景下不能互换： a)时间驱动/事件驱动：内部系统一般可以通过时间来驱动，但涉及到外部系统，则只能使用时间驱动。如怕取外部网站价格，每小时爬一次b)批量处理/逐条处理：批量处理堆积的数据更加高效，在不需要实时性的情况下比消息中间件更有优势。而且有的业务逻辑只能批量处理。如移动每个月结算我们的话费c)实时性/非实时性：消息中间件能够做到实时处理数据，但是有些情况下并不需要实时，比如：vip升级d)系统内部/系统解耦：定时任务调度一般是在系统内部，而消息中间件可用于两个系统间 java有哪些定时任务的框架单机 timer：是一个定时器类，通过该类可以为指定的定时任务进行配置。TimerTask类是一个定时任务类，该类实现了Runnable接口，缺点异常未检查会中止线程 ScheduledExecutorService：相对延迟或者周期作为定时任务调度，缺点没有绝对的日期或者时间 spring定时框架：配置简单功能较多，如果系统使用单机的话可以优先考虑spring定时器 分布 Quartz：Java事实上的定时任务标准。但Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能 TBSchedule：阿里早期开源的分布式任务调度系统。代码略陈旧，使用timer而非线程池执行任务调度。众所周知，timer在处理异常状况时是有缺陷的。而且TBSchedule作业类型较为单一，只能是获取/处理数据一种模式。还有就是文档缺失比较严重 elastic-job：当当开发的弹性分布式任务调度系统，功能丰富强大，采用zookeeper实现分布式协调，实现任务高可用以及分片，目前是版本2.15，并且可以支持云开发 Saturn：是唯品会自主研发的分布式的定时任务的调度平台，基于当当的elastic-job 版本1开发，并且可以很好的部署到docker容器上。 xxl-job: 是大众点评员工徐雪里于2015年发布的分布式任务调度平台，是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。 分布式任务调度系统对比 参与对比的可选系统方案： elastic——job （以下简称E-Job）与 xxx-job(以下简称X-Job) 项目背景及社区力量X-Job ： 大众点评公司下员工许雪里、贡献者 3人; github有2470star、1015fork | QQ讨论群6个 | 有登记在使用的超过40家公司 | 文档齐全E-Job ： 当当网开源，贡献者17人; github有2524star、1015fork | QQ讨论群１个、源码讨论群１个 | 有登记在使用的超过50家公司 | 文档齐全 ｜ 有明确的发展计划 支持集群部署X-Job ： 集群部署唯一要求为：保证每个集群节点配置（db和登陆账号等）保持一致。调度中心通过db配置区分不同集群。 执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。集群部署唯一要求为：保证集群中每个执行器的配置项 “xxl.job.admin.addresses/调度中心地址” 保持一致，执行器根据该配置进行执行器自动注册等操作。 E-Job ： 重写Quartz基于数据库的分布式功能，改用Zookeeper实现注册中心 作业注册中心： 基于Zookeeper和其客户端Curator实现的全局作业注册控制中心。用于注册，控制和协调分布式作业执行。 多节点部署时任务不能重复执行X-Job ： 使用Quartz基于数据库的分布式功能E-Job ： 将任务拆分为n个任务项后，各个服务器分别执行各自分配到的任务项。一旦有新的服务器加入集群，或现有服务器下线，elastic-job将在保留本次任务执行不变的情况下，下次任务开始前触发任务重分片。 日志可追溯X-Job ： 支持，有日志查询界面E-Job ： 可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job目前提供了基于关系型数据库两种事件订阅方式记录事件。 监控告警X-Job ： 调度失败时，将会触发失败报警，如发送报警邮件。 任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔 E-Job ： 通过事件订阅方式可自行实现 作业运行状态监控、监听作业服务器存活、监听近期数据处理成功、数据流类型作业（可通过监听近期数据处理成功数判断作业流量是否正常,如果小于作业正常处理的阀值，可选择报警。）、监听近期数据处理失败（可通过监听近期数据处理失败数判断作业处理结果，如果大于0，可选择报警。） 弹性扩容缩容X-Job ： 使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力E-Job ： 通过zk实现各服务的注册、控制及协调 支持并行调度X-Job ： 调度系统多线程（默认10个线程）触发调度运行，确保调度精确执行，不被堵塞。E-Job ： 采用任务分片方式实现。将一个任务拆分为n个独立的任务项，由分布式的服务器并行执行各自分配到的分片项。 高可用策略X-Job ： “调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；E-Job ： 调度器的高可用是通过运行几个指向同一个ZooKeeper集群的Elastic-Job-Cloud-Scheduler实例来实现的。ZooKeeper用于在当前主Elastic-Job-Cloud-Scheduler实例失败的情况下执行领导者选举。通过至少两个调度器实例来构成集群，集群中只有一个调度器实例提供服务，其他实例处于”待命”状态。当该实例失败时，集群会选举剩余实例中的一个来继续提供服务。 失败处理策略X-Job ： 调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；E-Job ： 弹性扩容缩容在下次作业运行前重分片，但本次作业执行的过程中，下线的服务器所分配的作业将不会重新被分配。失效转移功能可以在本次作业运行中用空闲服务器抓取孤儿作业分片执行。同样失效转移功能也会牺牲部分性能。 动态分片策略X-Job ： 分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。 执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务； E-Job ： 支持多种分片策略，可自定义分片策略 默认包含三种分片策略： 基于平均分配算法的分片策略、 作业名的哈希值奇偶数决定IP升降序算法的分片策略、根据作业名的哈希值对Job实例列表进行轮转的分片策略，支持自定义分片策略 elastic-job的分片是通过zookeeper来实现的。分片的分片由主节点分配，如下三种情况都会触发主节点上的分片算法执行：a、新的Job实例加入集群b、现有的Job实例下线（如果下线的是leader节点，那么先选举然后触发分片算法的执行）c、主节点选举” 和quartz框架对比 调用API的的方式操作任务，不人性化； 需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。 调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务； Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。 综合对比 总结和结论 共同点： E-Job和X-job都有广泛的用户基础和完整的技术文档，都能满足定时任务的基本功能需求。 不同点 X-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用 E-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用 附 定时任务的其他方案发货后超过10天未收货时系统自动确认收货的多种实现方式 每天定时半夜筛选第二天 可以自动确认收货的订单,然后第二天 每10分钟 执行一次确认收货 开销不会太大吧 时间也相对精确 自动确认收货这个状态如果仅仅是让客户端看的话，等用户下一次上线的时间，做一次运算就可以了。 延迟和定时消息投递ActiveMQ提供了一种broker端消息定时调度机制。适用于：1、不希望消息马上被broker投递出去，而是想要消息60秒以后发给消费者，2、想让消息没隔一定时间投递一次，一共投递指定的次数RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter。利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。]]></content>
      <categories>
        <category>微服务</category>
        <category>定时任务</category>
      </categories>
      <tags>
        <tag>分布式架构</tag>
        <tag>微服务</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计6大原则]]></title>
    <url>%2F2017%2F08%2F11%2FJava%E8%AE%BE%E8%AE%A16%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[所谓无招胜有招，练一门功夫分为内功和外功。外功好比招式，就是所谓的23种设计模式。而内功呢，就是心法，那就是这6种法则。光会外功那是花拳绣腿，内功修为才是境界。如此众多的设计模式，学完2遍，3遍可能也会忘的只记得单例和工厂模式。但是只要原则记住，在以后的设计中，有意无意就会用的设计模式的精髓。一 ： 类单一职责原则： 一个类只有一个引起这个类变化的原因。即一个类只完成一个功能，如果做不到一个类只完成一个功能，最少要保证一个方法只完成一个功能。 二：依赖倒置原则： 高层组件应该依赖抽象而不依赖具体，即面向接口编程，一般依赖的成员变量或者参数都应该是抽象的不应该是具体的。 三：里氏代换原则： 凡是父类出现的地方都可以用子类代替并且原功能没有发生变化，子类不应该覆盖父类的非抽象方法。 四：迪米特法则： 一个类要尽量的封装自己，一个类只与自己的朋友类打交道一般朋友类是成员变量或者参数，非朋友类一般都是局部变量 五：接口隔离原则： 一个接口完成的功能尽可能的单一，不要让一个接口承担过多的责任。 六：开闭原则： 对扩展开放，对修改闭合]]></content>
      <tags>
        <tag>Java设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[领域驱动设计原理]]></title>
    <url>%2F2017%2F08%2F06%2F%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[使用领域驱动设计的业务价值1、你获得了一个非常有用的领域模型2、你的业务得到了更准确的定义和理解3、领域专家可以为软件设计做出贡献4、更好的用户体验5、清晰的模型边界6、更好的企业架构7、敏捷、迭代式和持续建模8、使用战略和战术新工具 领域驱动设计参考项目推荐1.IDDD_Samples实现领域驱动设计作者VaughnVernon 所做的四种不同实现https://github.com/VaughnVernon/IDDD_Samples 2.dddsample-core领域驱动设计(Domain Driven Design)的官方参考架构，该架构分成了Interfaces、Applications和Domain三层以及包含各类基础设施的Infrastructure。https://github.com/citerus/dddsample-core 3.Axon-trader基于命令查询职责分离(CQRS)模式的一种领域驱动实现https://github.com/AxonFramework/Axon-trader，依赖框架 https://github.com/AxonFramework/AxonFramework其中有整合disruptor的实现的命令总线和自身的命令总线。Disruptor是一个高性能的异步处理框架，或者可以认为是最快的消息框架(轻量的JMS)，也可以认为是一个观察者模式实现，或者事件-监听模式的实现，直接称disruptor模式。disruptor最大特点是高性能，其LMAX架构可以获得每秒6百万订单，用1微秒的延迟获得吞吐量为100K+。 《领域驱动设计模式、原理与实践》 整理思维导图]]></content>
      <categories>
        <category>领域驱动设计</category>
        <category>模式、原理与实践</category>
      </categories>
      <tags>
        <tag>领域驱动设计</tag>
        <tag>领域驱动设计模式</tag>
        <tag>领域驱动设计原理与实践</tag>
      </tags>
  </entry>
</search>
