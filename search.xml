<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[敏捷教练第02课-储备-Scrum 精要]]></title>
    <url>%2F2018%2F05%2F14%2F%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81%2F</url>
    <content type="text"><![CDATA[介绍 Scrum 的书虽然还没有达到汗牛充栋的程度，但已经是著作等身了——所有著作加起来能够等同于一个人的身高了。本文并不是对 Scrum 理论的简单重复，而是立意能做到两点： 涵盖 Scrum 中所有重要的概念。 所介绍的方法达到说明书的程度，拿过去就能用。 敏捷产生的历史背景首先简要谈一下敏捷产生的历史背景，以及由 Scrum 及其众多兄弟方法共同抽象出的敏捷宣言。 敏捷产生的历史背景，在于世界变化越来越快。人们不断产生更多更新的需求，技术因此不断进步，两者交相辉映，使得变化越来越快。 以通信行业为例，从 1G 到 5G 呈现出一种升级越来越快的状态。 1986年，作为 1G 标志的使用模拟信号的世界上第一套移动通信系统在美国芝加哥诞生。 1995年，诺基亚崛起，进入数字调制的 2G 时代。 2009年左右，CDMA 大行其道，进入数据传输速率更高的 3G 时代。 2013年左右，伴随移动互联网，移动通信进入网速更高的 4G 时代。 最近一两年，随着 AR、VR、车联网、物联网的诞生，5G 的商用化指日可待。 在这种变化越来越快的环境之下，传统的软件开发方法不再奏效。敏捷先驱们开始探索一些新的方法，对丰田生产方式、组织模式等进行了大量学习，发明了 Scrum、XP 等各种方法论。2001年，新方法论的创始人们聚首一堂，总结了各家方法论的共同点，提出了敏捷软件开发宣言。 敏捷宣言有4个价值观和12个原则，它们也是 Scrum 的基础。对4个价值观要能够背诵下来，对12个原则也要熟悉，以便达到遇到实践情况时能容易对照的目的。我们为您精制了手绘版的敏捷宣言价值观和原则，可以打印张贴备查。 敏捷软件开发宣言我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观： 个体和互动 &gt; 流程和工具 工作的软件 &gt; 详尽的文档 客户合作 &gt; 合同谈判 响应变化 &gt; 遵循计划 也就是说，尽管右项有其价值，我们更重视左项的价值。 敏捷宣言遵循的原则 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。 业务人员和开发人员必须相互合作，项目中的每一天都不例外。 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。 可工作的软件是进度的首要度量标准。 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。 以简洁为本，它是极力减少不必要工作量的艺术。 最好的架构、需求和设计出自自组织团队。 团队定期地反思如何能提高成效，并依此调整自身的举止表现。 Scrum 方法论我们力求把方法论介绍到可操作的程度，从方便理解和记忆的角度，Scrum 方法论可以被概括为3355 3个角色 PO（产品负责人） SM（Scrum Master） 团队成员。 3个物件 Product Backlog（产品列表） Sprint Backlog（迭代列表） Product Increment（产品增量） 5个会议 Product Backlog Grooming （产品列表精化） Sprint Planning（迭代计划会） Daily Stand（每日站会） Spring Review （迭代评审会） Sprint Retrospective（迭代回顾会） 5个价值观勇气，承诺，专注，开放，尊重。 Scrum 由上述四种要素及背后的规则粘合起来。 3个角色各有担当又通力合作。 3个简单的物件统摄产品层面与迭代层面的交付物。 5个会议贯通产品层面与迭代层面的计划与执行活动。 5个价值观作为方法论的一部分，体现了 Scrum 以价值观为方法论的特色。 3个角色的职责###Scrum Master 的职责Scrum Master 的职责最难讲得清楚。有一个思路是参照卡诺模型。日本教授把产品需求分为三类： 必备型需求：这类需求没有满足，客户不会购买这个产品。 多多益善型需求：这类需求的实现程度与客户付钱的愿望呈线性关系。 喜出望外型需求：这类需求是区别于竞争产品的分水岭，客户愿意付出溢价。按照这个思路，我们可以把 Scrum Master 的职责分为三类： 必备型职责：协助管理 Scrum 的3个物件和5个会议。 多多益善型职责：与各方沟通和协调问题解决。 喜出望外型职责：系统思考，发现流程和团队工作中的改善点，并推动改善。 产品负责人职责管好产品列表。理解了什么是好的产品列表，也就理解了产品负责人的职责。后面会讲产品列表。 团队职责与传统团队职责不太一样的主要有两点： 跨职能：个人不一定是全能的，但团队要是全能的，具备把产品列表变成产品增量的全部技能。团队成员之间，不受角色和头衔的制约，只要具备能力，每个人都可以认领所有任务。 自组织：团队自行决定自己的工作方式，只要团队有共识。原则上是全员参与估算和计划，全员进行项目进度的监控和调整。在现实的团队中，有专职人员，也可能有浮动人员，不管是专职人员还是浮动人员，几个共同的基础是：自动化与及时化，每个人都做好本职工作，彼此之间良好配合；每个人都理解团队的产品目标和迭代目标；每个人都了解团队的工作方式和节拍。 浮动人员的类别一类浮动人员，例如架构师和设计师，有全局影响，但又不是全职参与。有两种变通的参与方式，一是跟专职人员一样，参加 Scrum 会议，二是在团队中指定他的影子，与他密切协作保证他能及时贡献到团队的目标。 二类浮动人员，如固定在两个团队之间共享的测试人员。 减少共享的人数，尽量把测试人员固定在其中一个团队；由有能力多任务的资深人员在两个团队之间浮动领任务，以缓解对其他人员的共享需要；在极端情况下，才让（1）中的人员也在两个团队之间浮动。三类浮动人员，如在一段时间之内有部分时间花在该 Scrum 团队的人员。与一类浮动人员相比，这类人员的全局影响相对小，更多是因为技能或资源问题而导致的安排。其变通的参与方式与一类浮动人员类似。 四类浮动人员，如尚不能独立工作的新员工。变通的方法是由其导师协助领取任务。 团队之要 在 Scrum Master 的引导和辅导下理解 Scrum 框架，特别是从事情角度的严密的 PDCA 循环，和从人的角度的紧密合作。 以严密的纪律性使 Scrum 能良好运转，达成业务上的目标，并收获高效快乐的团队。 在纪律的支撑之下，技术上精益求精，更好地发挥创造性，包括在技术领域，并适当参与产品探索领域。Team 在 Scrum 中的活动 梳理 计划 执行 每日检查和适应 迭代检查和适应（评审与回顾）Team 特征 自组织：自组织不能来自命令与控制，而是简单规则支持下的群游。 跨职能团队：多样性，跨职能，不同背景，不同的思考角度，造就更好的产出，更快更好的解决方案、更棒的创新。 一专多能 火枪手精神（互助） 宽带宽沟通（沟通带宽递减：面对面 &gt; 电话 &gt; 即时消息 &gt; 邮件） 透明 团队大小5~9人 专注与承诺 可持续步伐 长期稳定的团队 3个物件产品列表（Product Backlog） 产品列表（Product Backlog）是产品列表项（Product Backlog Item，简称PBI）的列表。PBI 包括特性、故障、技术工作和知识学习。 好的产品列表要满足 DEEP 原则： Detailed Appropriately 细节得当。越是马上要做的 PBI，越是要有足够的细节。很久以后才做的，可以粗略一点。 Emergent 涌现式的。PBI 可以根据实际情况随时插入。 Estimated 有估算的。同样是近期要做的 PBI，估算要较精细，可以采用费波纳契序列的故事点估算，即1，2，3，5，8 …对于远期要做的 PBI，估算可以粗略，可以采用粗略的T恤尺寸估算，即 XS，S，M，L，XL 等。 Prioritized 排好优先级的。近期要发布版本中的 PBI 的优先级要明确排列，中期的可粗略排列，远期的可不必排列。 迭代列表迭代列表由从产品列表中选出当前迭代要完成的 PBI，及由 PBI 分解产生的任务构成。对于任务的估算，可以采用天或小时估算，也可以不估算。采用哪种方式，以团队能够做出靠谱的迭代承诺，以及在迭代工作的每一天方便监测趋势为标准。 产品增量产品增量是一个迭代结束时，输出的用户可用的新功能。产品增量要达到潜在可交付状态，即如果用户需要，可以快速部署给用户使用。 5个价值观5个价值观的落实与否，是 Scrum 团队形成的重要标志。 对于5个价值观的运用，可以由团队一起讨论，每个价值观分别意味着什么，并进而把价值观转化为可执行的团队规范。利用迭代回顾会议，审视团队规范的执行情况。 5个会议产品列表精化会目的：准备好。准备好的意思是，经过精化，PBI 达到可估算可计划和可执行的状态。开发人员可以对之进行开发工作了。 流程：主要是围绕 DEEP 标准 细节得当。产品负责人讲解每个 PBI，达到团队成员理解需求的程度。涌现式。在精化的过程中，根据产品负责人与团队的互动，可能会产生新的 PBI。估算。在产品负责人讲完每个 PBI 时，团队可以用估算纸牌进行估算。通过纸牌对话，也可以保证每位团队成员都理解了需求。优先级。优先级主要由产品负责人排列，但团队的估算和实现的难易程度，也会影响产品负责人重新考虑优先级的排列。 辅助物件：为了保证产品列表精化达到准备好的标准，可以制定一个叫做准备好的定义（Definition of Ready，简称DoR）的检查列表。DoR 列表示例如下： 业务价值清晰。 团队了解需求细节，能够做出是否能完成的决定。 依赖被清楚地识别和管理，没有妨碍完成 PBI 的依赖。 团队具备完成 PBI 的技能。 PBI 被估算，并且足够小，能够装到一个迭代里。 验收标准清晰和可测试。 性能指标清晰和可测试。 团队知道在完成后如何演示。 迭代计划会目的：在计划会结束时，给出靠谱的迭代承诺。流程： 产品负责人建议迭代目标和要完成的 PBI。 团队把 PBI 分解成任务。 团队决定是在计划会上就把所有任务分配到个人，还是在迭代过程中动态分配。分配的方式是团队成员认领。要不要分配的标准是，团队是否能对迭代计划进行承诺。 评估计划的工作量与团队容量是否平衡。 从迭代计划中提炼出迭代目标，把 PBI 粘合在一起，把团队团结在一起。 团队对迭代目标和计划进行承诺。 辅助物件：为了对完成有统一的标准，需要完成的定义（Definition of Done，简称DoD）检查列表。DoD 检查列表示例如下： +设计有评审。+代码完成，包括：代码有重构，代码符合标准，有注释，有签入，有评审。+用户文档更新。+测试完成，包括：单元测试，集成测试，回归测试，平台测试，语言测试等。+零已知故障。+验收测试完成。+部署到生产环境。 可以用 A1 纸和便利贴辅助计划会议： Scrum 的两个要点是：人的有效参与，做事的有效轨道。 这个计划会的设计，是以有效的轨道辅助人的主动参与。 贴出一张 A1 大白纸。 左边第一列是故事，由 PO 用同一种颜色的便利贴书写和表达。字要大，用白板笔写，保证不用站得很近也能看清楚。故障，新特性或任何要交付的事情统称故事。故事右边，用另一种颜色的便利贴列出任务。任务是为完成故事所要做的事，由团队书写。可以写上任务的执行人与估算。 整个会议，一次围绕一个焦点，即当前讨论的故事。以故事为单位流动起来。 PO 的注意事项：清晰讲述。随着会议的焦点流动，把故事讲得让团队明白。 SM 的注意事项：适度引导。控制焦点与流动，一个故事充分讨论完并分解成任务，再进行下一个。保持紧凑的节奏和整体时间盒。 团队注意事项：主动参与。一是对故事不清楚的主动提问，而是主动参与任务分解、估算、认领。 全部故事讨论完和分解成任务后，统计每人工作量，看工作量与容量是否平衡，个人之间工作是否能置换以达到每个人的工作相对均衡。最后是团队决定是否能对迭代计划和目标承诺。 每日站会目的：围绕目标同步进度，掌握对于完成目标的趋势。流程： 准时开始。每天固定时间和地点。 每人回答三个问题：为了帮助团队达到迭代目标，昨天完成了什么，今天打算完成什么，遇到了什么障碍。 总结趋势和风险。 15分钟之内结束。 站会中细颗粒度的协作： +利用站会，促进细颗粒度协作。+故事和任务拉动按优先级进行。+需要协作的任务，其所有者勇于发起协作请求。+被请求者以协作的任务先于本人可独立承担的任务进行。+在回顾会议中明确讨论该模式，并贯彻。+模式可以由任何一人发现。 关于站会中的发散讨论： +站会中发散讨论的度以全部团队成员觉得爽为标准。+15分钟时间盒不必严格遵守。+Scrum Master 需要对站会之后团队成员的日程有了解，以便判断站会延长一点是否产生影响。+Scrum Master 可以观察对于发散讨论是否全部或大部分团队成员沉浸其中，如果是，暂不打断。+如果出现较多分神现象，打断讨论，并提议会后安排讨论。+或者根据站会的剩余时间，询问团队，这种发散的讨论是否会影响团队成员的后续日程。+按以上原则，打断可以由任何一人提出。+在回顾会议明确探讨这种情景中的模式。 迭代评审会目的：了解过去一个迭代完成了什么，并对下一步做出预测。流程：+产品负责人邀请客户和干系人参与。+团队总结过去一个迭代的成就和克服的挑战。+团队演示完成的产品，获得反馈。+产品负责人分享来自用户和市场的信息，预测调整发布计划，预测下一迭代的内容。 ###迭代回顾会 目的：团队建设，发掘和计划改善。流程： 基调：真诚和有效。排除顾虑，真诚表达。提出有效的问题，落实有效的方案。 白板上写两个栏目：感谢，改善。 每人（包括 PO 和 Scrum Master）用 Post It 写出要感谢的人，每张 Post It 写一个，数量不限。写完贴在白板。 每人（包括 PO 和 Scrum Master）用 Post It 写一个最痛的改善点，只写一个就好。写完贴出来。 Scrum Master 无需太多发言，只需起一个指针的作用。先从感谢的纸条开始，一张一张拿出来问是谁写的，写的人面向要感谢的人表达感谢，不能太空洞，要谈一下感谢的内容。 然后转向改善栏目，Scrum Master 同样不要多说话，一张一张拿起纸条，让写的人讲，其他人可以参与讨论，这个环节焦点放在问题澄清，而不是解决方案，Scrum Master 对这一点要有一定把控。 每张纸条讲完后，所有人当场举手或竖大拇指，表达的是认为这个问题是否要尽快即在下一迭代解决。 全部问题澄清后，全体针对要解决的问题，讨论方案。Scrum Master 关注一下讨论的流动情况，既不要太乱，也不要冷场。极端情况下，可以点名让大家逐一发言，但尽量不用这一招。 产生的方案，形成改善 Backlog。Scrum Master 要跟踪起来，可以在日常或站会中跟踪落实情况。 Scrum Master 要观察团队互动中的交互情况，如果有分歧点，就是改善点。比如说在 Demo 中，PO 对验收标准的理解与团队不一致。这就是需要改善的地方。改善的讨论和进行，可以在日常与相关人员讨论，也可以放到回顾会议。 除了团队的回顾会议，还可以有一对一的回顾会议： 一对一 Retrospective 是对团队 Retrospective 的鼓励和驯化。是为了帮助打磨团队 Retrospective。 一对一 Retrospective 是对团队 Retrospective 的补充。即使团队 Retrospective 已经搞得很好了，也还需要一对一 Retrospective。 一对一 Retrospective 可以由 Scrum Master 发起，也可以由任何人向任何人发起。 一对一 Retrospective 的目的，是加强人与人之间的连接，传递改善的信念，和计划和执行改善。 一对一 Retrospective 的边界，是围绕改善的基调，就与团队项目工作相关的事进行讨论。 一对一 Retrospective 的框架，可以包含探询交流对象对工作方式的反馈、探询痛点和关注的问题，和以 Scrum 实践和角色要求为基准、以观察到的行为为依据向交流对象提供的反馈。还可以包含不同团队之间的经验传递、桥梁和延展。 如果希望痛点和问题的探询更封闭一点，可以分解为几个角度：就团队项目工作的上下文而言，您的目标和期望的理想状态是什么？与现状的差距是什么？流程上有什么问题，或有什么妨碍理想状态的达到？团队合作方面呢？团队工作绩效和质量呢？任何其他方面？ 这个框架的运用要灵活。人的主动参与重于规则。如果人能主动参与改善事项的发掘、计划和行动，框架就可以放下。 Scrum Master 日常有力的观察是 Retrospective 的重要输入。 各个角色的普适标准：专业、尊重、坚持。 改变的第一原则：一切改变基于自愿。改善的用意是改善系统，不是改变个人。 最后用十论 Scrum 就是知行合一对 Scrum 作个小结： 人人知行合一：人人计划，人人行动。 时时知行合一：时时计划，时时行动。 团队知行合一：团队决定，团队行动。 敏捷知行合一：快速决定，快速行动。 需求知行合一：接近客户，掌握需求。 支柱知行合一：检验是知，适应是行。 完成知行合一：定义完成，共识目标。 透明知行合一：高度透明，流畅过程。 纪律知行合一：自我纪律，助长能力。 美德知行合一：积极主动，集思广益。]]></content>
      <categories>
        <category>敏捷Scrum</category>
        <category>敏捷教练和 ScrumMaster</category>
      </categories>
      <tags>
        <tag>Scrum 精要</tag>
        <tag>敏捷</tag>
        <tag>Scrum</tag>
        <tag>敏捷教练和 ScrumMaster</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷教练第01课-敏捷教练和 ScrumMaster 基本功四部曲]]></title>
    <url>%2F2018%2F05%2F14%2F%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2%2F</url>
    <content type="text"><![CDATA[课程概述敏捷教练是一个职业。Scrum Master 和敏捷教练是同一职业的不同阶段。当一个人能带好一个 Scrum 团队时，他是一个 Scrum Master。当他能带各种不同类型的团队，并持续追求更好，他就是一个敏捷教练。 Scrum Master 职责的范围和边界相对确定，敏捷教练职责的范围和边界相对不确定。但从学习的角度，他们所需要的基本功是一致的。本课程中对这两个角色，在大多数时候不太区分。鉴于这两个角色既有相似处又有区别，大家在使用时对这两个名称的理解上又有变异，所以课程的名称中就把这两个名称并称，以求相对准确地表达这个课程所要服务的角色。就算是您所采用的敏捷方法不是 Scrum，依然可以从本课程中受益。 如同任何其他职业，敏捷教练有它的技能，也需要并且能够通过练习达到精通。我们可以通过四部曲的结构理解敏捷教练这个职业及其技能： 目的：任何一个职业，都有它存在的目的。这个目的包括职业产生的背景，工作的环境，以及所承担的职责。 储备：即敏捷教练所必备的基础知识。 技巧：即如何运用基础知识履行职责。 实战：即在一个典型完整的工作周期中，如何利用储备和技巧取得成功。 本章会介绍： 敏捷教练这个职业产生的背景 敏捷教练的工作环境 敏捷教练的职责 体系化的参考书目 敏捷教练职业产生背景 “追求更好”旅途的守护者 敏捷方式可以追溯到1620年弗朗西斯·培根（Francis Bacon）科学方法的发源时期。更合理一点的起点可能是在20世纪30年代，那时候贝尔实验室的物理学家和统计学家沃特·阿曼德·休哈特（Walter A. Shewhart）开始使用计划-执行-学习-调整（PDSA）循环对产品和过程进行改善。 休哈特把这种反复渐进的开发过程教给了他的学员戴明（W.Edwards Deming），后者在二次大战后的日本大量使用了该方法。戴明将 PDSA 改造为 PDCA。丰田公司雇用了戴明来培训公司中数百名经理，并在他的经验之上创立了著名的丰田生产体系——这也是如今精益思想的最初由来。这种反复渐进的方式对于20世纪50年代的 X-15 超音速飞机的制造也是贡献巨大。 丰田模式的关键，以及使丰田有杰出表现的原因并不是任何个别要素，而是一个由各要素组成的 4P 体系： 长期理念（philosophy）：重视着眼于长期的思维，公司高层注重为顾客及社会创造与提升价值，这个目的主导了该公司的长期方法——建立学习型组织，投资于人员、产品与工厂，以及绝不松懈地坚持质量，以适应环境的变迁，成为高效的组织。 正确的流程（process）：正确的流程方能产生优异成果，流程是以低成本，高安全性与高昂的士气达成最佳质量的关键。 借助员工与合作伙伴（people and partner）的发展，为组织创造价值：丰田公司管理层的看法是，他们打造的是“人”，不是汽车。尊重员工的智慧和能力，并不断激励他们做得更好。 持续解决根本问题（problems）是组织型学习的驱动力：丰田模式的最高境界是组织型学习，丰田的持续学习制度重心在于辨识问题的根源，并预防问题的发生，持续改善。 此体系必须每天以贯彻一致的态度实行，而非只是一阵旋风。这个体系成功的秘诀是，经理即教练。培养深谙公司理念的领袖，使他们能教导其他员工。这是我们今天思考敏捷教练职责的最重要参照物。丰田的 4P 模式，也能帮助我们从根本上去思考什么是敏捷。 大野耐一是将丰田生产方式体系化的重要人物。大野耐一退休后，与其弟子创建了 NPS（New Production System），为其他企业服务。精益教练诞生，教练与经理分离。这也预示着在今天敏捷教练和管理者通常是分离的职位。 Scrum 的另一根植于日本的基础，是1986年野中郁次郎和竹内弘高在哈佛商业评论上发表的名为《新的新产品开发游戏》的文章。通过研究那些比竞争者更快发布新产品的制造商们，比如富士-施乐的复印机，本田的摩托车引擎，佳能的照相机，定义了以团队为基础的新的产品设计和研发过程。这种过程不是通常在产品开发中的“接力赛”——一组专家完成产品部分功能并将项目传递到下一组专家手中。这种方式被野中郁次郎和竹内弘高称作为“橄榄球”方式，“团队试图作为一个整体完成所有任务，将球传来传去。” 在1993年，Jeff Sutherland 面临一项似乎是不可能完成的挑战：Easel 是一家软件公司，需要在半年之内开发一款新产品来替代它的传统产品。Jeff Sutherland 通晓很多方法，比如快速应用程序研发，面向对象设计，PDSA 循环，专案工作等等。他希望在公司总部建立一个类似于专案工作的文化氛围，将组织分割和合并的好处结合起来。他开始学习任何和提高组织效率相关的知识。通过阅读上百篇研究报告和顶尖的产品管理专家面谈，他脑海中逐渐有了一些有煽动力的想法。 这中间有一个想法来自于贝尔实验室的关于 Borland Quattro Pro 团队的文章。该文章主张，每天短的团队会议能显著增加团队效率。而 Jeff Sutherland 的核心概念则来自于竹内弘高和野中郁次郎的“橄榄球”方式，虽然该方法更关注制造过程而不是软件开发过程。通过借鉴哈佛商业评论文章中的关键想法和进行一些特别的试验，Jeff Sutherland 创建了一种新的软件开发方法，归功于橄榄球带来的灵感，Sutherland 将这种方法称为“争球”（Scrum）。Scrum 方式最后确保了他准时完成了似乎不可能的任务，也没有超出预算，程序漏洞比之前版本还要少很多。Sutherland 随后就长时间和 Ken Schwaber 对该方法进行长期研究，并在1995年两人首次在公众面前发布 Scrum 的方法。 在2001年，17位自称“有组织的无政府主义者”在美国犹他州的雪鸟滑雪场会面，分享他们的想法。Jeff Sutherland 和其它 Scrum 的先驱也在其中。参与者们分享了互相竞争的几种方式：极限编程（XP）、水晶方法、自适应软件开发（ASD）、特性驱动开发（FDD）、动态系统开发方法（DSDM）。所有这些方式都是“轻量版”的框架，因为这些方法使用更少、更简单的规则来适应快速变化的环境。不少与会者都觉得“轻量”这个术语挺适用的。 虽然与会者不能在方法上达成一致，但是他们还是为这个运动取了个名字：敏捷。这个词是一位参与者提出的，他当时正在读《敏捷竞争者和虚拟组织：给客户更多的策略》一书。书中列举了100家公司的例子——包括 ABB， 联邦快递，波音，博士和哈雷戴维森，这些公司正在创建适应动荡市场的新方法。有了这个名字，参与者达成一致，发布了“敏捷软件开发宣言”，该宣言中突出了每个人都同意的4个关键价值。稍后在会议中，以及之后的几个月中，他们发展了12个原则，被称为“敏捷宣言背后的原则”。 从2001年开始，所有的开发框架，以及与之匹配的价值观和原则就被称作为敏捷技术。 同时，敏捷方法继续演化。在20世纪80年代后期和90年代前期，MIT 的研究学者们开始研究日本的制造体系，特别是丰田生产体系。他们借用了名词“精益”来描述改善效率的这套体系，包括消除浪费（muda)， 减少波动（mura）和降低负荷（muri）。虽然精益方法并没有在雪鸟会议上被表述成敏捷方法，但是精益和看板软件开发系统在后来被并入敏捷系统。在开始时候，一些纯粹的敏捷主义者拒绝承认精益方法。 但是精益宣传该方法能关注客户协作，最终更多的敏捷践行者开始接受精益，看板，还有混合方法（比如 Scrumban 和 Lean scrum），作为敏捷价值和原则合法的应用。 这些新方法论的创始人们是精通技术的管理者，和管理者中的思想者。敏捷宣言的17位创始人，是敏捷思想的传道者，可以被认为是最早的敏捷教练。他们所创造的这些方法的本质，不是一些死板的规定，而是在追求“更好”的旅途中，作为承载“更好”的载体。这些方法论的落地，以及作为这些方法论内在精神的追求“更好”，不会自动发生。 一种可能的逻辑是，由管理者来承担落实新方法论的责任。管理者可以转型为教练，重拾作为精益鼻祖的丰田的精神。对于管理者无法承担教练职责但又想追随敏捷潮流的组织，则需要专职的敏捷教练。 敏捷教练工作的环境守破离的概念来自日本，大致可以理解为遵守、突破和脱离。这个概念在敏捷界被广泛运用，含义也会有所变迁。下面这个关于组织所处阶段的守破离，来自于 Scrum 之父 Jeff Sutherland。 组织的守的状态 CEO 没有敏捷思维。以命令和控制的文化为主。 依据传统的管理层级结构产生项目组。 即使采用敏捷，也是跟风，流于形式，无法深入。 在这种状态之下的效率提升通常只能做到20%~30%组织的破的状态 CEO 改变管理者的角色。教练和支持的文化浮现。 管理者教导团队自组织和自管理。管理者成为领导者。 领导者为团队提供有挑战的排好优先级的目标。 消除组织债，创建可行的商业和组织计划，提供团队所需的资源。 识别和移除障碍，消除浪费和技术债，确保团队速率最大化。 确保产品负责人对交付的价值负责。 确保 Scrum Master 对流程改善和团队快乐负责。 确保团队对质量提升和技术债修复负责。 团队依据排好优先级的产品列表自我形成。 领导者在组织内驱动不同技能的虚拟实践社区，为组织提供能力建设。 领导者按需重构组织。 在生产力方面会取得200%~400%的提升。 示例公司：Spotify，SAP，Salesforce，Microsoft。组织的离的状态 层级仍然存在，但主要是为技能培养服务。 团队自组织负责产品方向和组织重构。 领导者支持团队所需的技能。 群游使组织在压力之下更强壮。 产生500%~1000%的生产力提升。 示例公司：Valve，Zappos，Morning Star，Gore，Grindr。 这三种状态，跟建国方略中的军政、训政和宪政暗合，可参照理解。 瓶颈通常在瓶子的上部，一个公司最大的瓶颈是 CEO。作为一个敏捷教练，针对所处的组织形态，可以采取运用敏捷基本功加上变通的方法来开展工作。 至于团队，也会有三种形态。 无组织团队 从团队绩效方面看，是相对不高和不稳定的，时好时坏。迭代计划预测的靠谱度较差，速度也不高。 从团队动态和互动看，呈现出一种各自为政的状态，沟通不畅，合作困难。从会议看，目的不明确，流程不清晰，效率低，参与者沮丧。自运转团队 从团队绩效看，呈现出相对稳定的状态，迭代目标承诺靠谱度较好，迭代目标基本能完成。 从团队动态和互动看，团队成员目标一致，有良好的沟通合作，在各项活动中，团队成员都能主动参与。会议的目的和流程清晰，没有 Scrum Master 的情况下，会议也能按照打磨好的流程自动运转起来。自组织团队 从团队绩效看，在稳定的基础上，呈现出阶段性的持续提升，生产率和质量不断提高。 从团队动态和互动看，团队有更多高质量的互动，团队除了关心共同的目标，还关心持续改善和从根本上解决问题。呈现出上文中所说的丰田 4P 的一些特征。 敏捷教练所要做的，就是把团队从无组织状态带到自运转状态，再进一步带到自组织状态。这个使命的履行，本课程中敏捷教练和 ScrumMaster 的基本功可以帮到您。 敏捷教练的职责：流程与人两手抓在设计本课程之前，针对一部分敏捷从业人员和经历者做了一个小调查，想了解他们对 Scrum Master 职责的理解。这个调查虽然样本较小，不具备统计意义，但依然可以帮助我们了解跟我们处在同样角色的人对这个问题怎么看。调查结果如下： 精通管理规则，精通业务梳理，极强的沟通协作能力，技术熟练，懂业务管理。 敏捷教练确保 Scrum 被正确的运用和贯彻，同时保护团队和引导新的想法落地。 Scrum Master 是牧羊犬的作用，让团队在一个迭代中不受打扰，同时他应该对敏捷的流程、理念有深入的了解，具有较强的管理能力。 引导团队进行效率的提升，通过各种工具的导入，来实现项目目标。但是，究竟是否要像传统团队一样，也要引导团队进行项目交付，并解决依赖问题，这个要商榷。 保证团队资源，保证各个角色及职责协作，解决团队开发中的障碍，协调解决沟通问题，保证开发过程按计划进行。 指导 Scrum 小组成员理解为什么、知道如何参与 Scrum 实践的每一个环节，把控好 Scrum 实践的产出，为整个小组的 Scrum 迭代/计划结果负责。 基于对 Scrum 角色的了解，以及对项目和资源的认识，帮助 stakeholder 决定最佳的按照 Agile 路线来实施项目的教练。 培训和指导团队践行敏捷实践；关注项目的度量数据，及时带领团队调整，加速或稳步前进；关注成员的状态，激励督促团队前进；带领和辅导团队按照敏捷和精益的方式做事，打造优秀自组织团队。 牧羊犬守护团队，流程；教练，培训，引导团队，PO，相关人知识，技能；推动过程改进，促进变革；提升团队，组织效能。 在敏捷团队中推进敏捷开发模式和流程，是团队的组织者，保证团队资源，协调内外部关系，解决出现的问题。 帮助团队进行敏捷实践落地，梳理流程，减少外部干扰，鼓舞士气，提高团队作战能力。提高工作效率。 传播敏捷思想，指导团队，指导 PO，组织敏捷会议，排除团队干扰。 指导团队按 Scrum 方式运转，传播 Scrum 思想，指导敏捷实践，提高效率。 保证团队资源完全可被利用并且全部是高产出的。保证各个角色及职责的良好协作。解决团队开发中的障碍。做为团队和外部的接口，屏蔽外界对团队成员的干扰。保证开发过程按计划进行，组织 Daily Scrum，Sprint Review and Sprint Planning meetings。 Scrum Master 是 Sprint 的负责人，Sprint 做得好不好的终责者。负责计划，执行 Sprint，并使团队团结及有自主创造能力。 搭建 team 架构，分配各个角色成员，开展 scrum 常规的事项，并让敏捷的理念深入人心。帮助团队更好的按照 Scrum 框架有效的运行，对团队遇到的问题和障碍提供帮助，协助扫清研发过程中的障碍，打造高效能的团队。 组织项目团队，承诺项目开发，回顾项目过程，总结项目经验教训，组织每日站会，制定 Sprint 计划。 Facilitate everything and eventually retire，留下一个自组织团队，悄然离去，深藏功与名。激励团队，coach，team lead，life tutor。 Scrum Master 应该是作为团队初步接触敏捷时作为流程与套路教授和规范。在团队逐步成熟后，Scrum Master 的职责可以旁落，而专职 Scrum Master 可以取消。 那么敏捷教练的职责到底是什么呢？ 《敏捷教练》一书的作者之一，瑞秋·戴维斯（Rachel Davies）对敏捷教练的观点： 概括地说，敏捷教练帮助团队在工作中应用敏捷实践，从而帮助团队发展的更健壮。接受这些变化需要时间，所以没法通过“点到即止”的方法立即让它们生效。你需要与团队长时间呆在一起，并帮他们，让他们更加关注工作流程、关注如何更有效地协作。你对团队的目标是在你离开后，让他们能“自我指导”并且擅长应用敏捷。这样不会限制敏捷教练向组织引进敏捷，以及建立新敏捷团队。 &lt; Coaching Agile Teams &gt; 的作者 Lyssa Adkins 对敏捷教练的观点： 敏捷教练确实非常重要，因为现在有许多人在运用一堆蹩脚的敏捷工作方式。即使运用了，它们只是更快地产出了平庸的结果，我知道，那并不是他们运用所谓“敏捷”工作方式的主要意图。我认为教练是帮助团队取得惊人成果所不可或缺的组成部分，因为所有的成果都是人互相交互所产生的。敏捷框架中没有说明如何处理人与人交互的部分。为了使敏捷框架良好运作，它当然会提供可让其正常运行的结构和容器。但是在敏捷框架之外，还有很多事情要做，还有很多东西需要带给团队，针对不同的规则，需要给团队很多建议——如冲突管理、敏捷促进、教导及指引人、专业指导等等。 本文给出的敏捷教练的职责定义是： 贯彻一种工作方式，包括精益、敏捷和系统思考。 打造自组织团队，特别是要面对人（包括自我与他人）这个最复杂的实体。 以此来消除浪费，增加价值，达到组织的目标。 要履行这些职责，需要理解敏捷，这是本课程基本功的储备部分；要能够在组织中用敏捷影响他人，这是基本功中技能的部分；要体会真实环境中的敏捷运用，这是本课程基本功中的实战部分。 体系化的参考书目 敏捷是敏捷教练的代码 敏捷的历史是一场不断追求更好的历史，在这个过程中，先行者们为我们留下了众多可供参考和让我们无须重新发明轮子的书籍。 本节以类库、框架、架构，和编辑、编译、链接、运行的视角解析敏捷和敏捷教练，以及如何运用先行者们留下的书籍。 敏捷是一种代码，2001年2月，17人在美国犹他州的雪鸟滑雪场，解码和发明了这门语言，并贡献了敏捷基础类库。 敏捷基础类库 Kent Beck 等的 （《敏捷宣言》）。 敏捷框架类库 Jeff Sutherland &amp; Ken Schwaber Kent Beck （《拥抱变化：解析极限编程》） Mike Cohn （《用户故事与敏捷方法》）（《敏捷估算与规划》） David Anderson （《看板方法》） Mary Poppendieck （《精益软件开发》） Craig Larman 的 Large Scale Scrum Dean Leffingwell 的 SAFe敏捷扩展类库 野中郁次郎和竹内宏高《新的新产品开发游戏》《场理论》 Henrik Kniberg （《硝烟中的 Scrum 和 XP 》） Kenny Rubin （《Scrum 精髓》） Jeff Patton （《用户故事地图》） Mitch Lacey （《Scrum 实战指南》） Ken Schwaber （《Scrum 敏捷项目管理》） Mike Cohn （《Scrum 敏捷软件开发》） Eric Ries （《精益创业》） Ellen Gottesdiener Jezz Humble （《持续交付》） 《戴明14条》 艾永亮《腾讯之道》 何勉《精益产品开发原则、方法与实施》精益类库 大野耐一 《丰田生产方式》《现场管理》 新乡重夫《从 IE 的角度看丰田生产方式》 James Womack （《改变世界的机器》）（《精益思想》） Jeffery Liker （《丰田模式》）系列 John Shook （A3 报告）（价值流图）引导与心理学类库 NLP 神经语言程式 世界咖啡 六顶思考帽管理与变革类库 Chip &amp; Dan Heath （《瞬变》） Jurgen Appelo （《管理3.0》） Jurgen Appelo （《变革管理3.0》） Daniel Pink （《驱动力》） （《重新定义公司》）敏捷模式类库 Scrum 本身就是个模式 《用户故事地图》也是模式 Linda Rising 本课程中的 Scrum 子模式，例如故事泳道、一人天任务、随机一分钟项目经理。敏捷教练方法类库 Lyssa Adkins 修身类库 《大学》《中庸》《论语》《孟子》 《王阳明全集》 《心经》《金刚经》 《圣经》 阿德勒《超越自卑》 《人生五大问题》 斯蒂芬柯维《七个习惯》 《红与黑》 《基督山伯爵》 《悲惨世界》 《百年孤独》 《活着》 《常识》而在设计敏捷工作方法的架构时，可以基于上面提到的敏捷框架中的一个或多个。可以使用的思维线索有： 软件开发的阶段：概念，机会，策略，需求，方案，计划，实施，验证，部署，维护，退役。 PDCA 5W2H 在做敏捷工作方法的实施时,第一步是需求： 与关键人员交流，了解问题与目标 这一步要放下敏捷的代码，倾听了解问题与目标本身。 第二步是制定解决方案： 根据现状，参考敏捷方法，制定关键举措。 使用类库和框架，制定架构。 敏捷工作方法的编码就是用上面的各种类库和框架，生成适合组织和团队的可执行的敏捷方法，包括架构和详细实现。执行的环境是团队中每个人的大脑。 编辑，是把方案细化的过程： 把敏捷方法动作化，做好剧本。无剧本，不操作。 为每一次谈话做好充分准备。 编译，是与团队中所有人交流的过程，使所有人理解敏捷方法： 可以是讨论，针对某个具体变化的方案与执行。 可以是培训，介绍整体或某个环节的工作方法。 可以是一对一交流，让方法切实而不只是形式上发生。 链接，是处理与现状和与已有工作方法的冲突： 分析问题，解决问题。 调整“代码” 运行，是新方法的执行： 落实每一个动作，并检查调整。 编辑、编译、链接、运行会反复多次进行，跟程序员写代码没有区别。]]></content>
      <categories>
        <category>敏捷Scrum</category>
        <category>敏捷教练和 ScrumMaster</category>
      </categories>
      <tags>
        <tag>敏捷</tag>
        <tag>Scrum</tag>
        <tag>敏捷教练和 ScrumMaster</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-微服务-网关模式]]></title>
    <url>%2F2017%2F10%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义API网关是一个服务器，它是系统中的单个入口点，用户对API网关进行单一呼叫，然后API网关调用每个相关的微服务器。它类似于面向对象设计的Facade模式。API网关封装内部系统架构，并提供针对每个客户端定制的API。它可能还有其他的责任，如身份验证，监控，负载平衡，缓存，请求整形和管理，以及静态响应处理。 优缺点使用API​​网关的主要优点是它封装了应用程序的内部结构。客户只需与网关进行通话，而不必调用特定的服务。API网关为每种类型的客户端提供了特定的API。这减少了客户端和应用程序之间的往返次数。它还简化了客户端代码。 API网关也有一些缺点。它是另一个高度可用的组件，必须开发，部署和管理。还有一个风险是API网关成为开发瓶颈。开发人员必须更新API网关以暴露每个微服务端点。重要的是更新API网关的过程尽可能轻。否则，开发人员将被迫排队等待更新网关。尽管存在这些缺点，但是对于大多数现实世界的应用来说，使用API​​网关是合理的。 类图]]></content>
      <categories>
        <category>设计模式</category>
        <category>微服务</category>
        <category>网关</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>设计模式</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 日期/时间（Date Time）API指南]]></title>
    <url>%2F2017%2F09%2F19%2FJava8-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%EF%BC%88Date-Time%EF%BC%89API%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[为什么我们需要新的Java日期/时间API？在开始研究Java 8日期/时间API之前，让我们先来看一下为什么我们需要这样一个新的API。在Java中，现有的与日期和时间相关的类存在诸多问题，其中有：1、Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。2、java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。3、对于时间、时间戳、格式化以及解析，并没有一些明确定义的类。对于格式化和解析的需求，我们有java.text.DateFormat抽象类，但通常情况下，SimpleDateFormat类被用于此类需求。4、所有的日期类都是可变的，因此他们都不是线程安全的，这是Java日期类最大的问题之一。5、日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。在现有的日期和日历类中定义的方法还存在一些其他的问题，但以上问题已经很清晰地表明：Java需要一个健壮的日期/时间类。这也是为什么Joda Time在Java日期/时间需求中扮演了高质量替换的重要角色。 Java 8日期/时间API设计原则1、不变性：新的日期/时间API中，所有的类都是不可变的，这对多线程环境有好处。2、关注点分离：新的API将人可读的日期时间和机器时间（unix timestamp）明确分离，它为日期（Date）、时间（Time）、日期时间（DateTime）、时间戳（unix timestamp）以及时区定义了不同的类。3、清晰：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用now()方法，在所有的类中都定义了format()和parse()方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。4、实用操作：所有新的日期/时间API类都实现了一系列方法用以完成通用的任务，如：加、减、格式化、解析、从日期/时间中提取单独部分，等等。5、可扩展性：新的日期/时间API是工作在ISO-8601日历系统上的，但我们也可以将其应用在非IOS的日历上。 Java日期/时间API包Java日期/时间API包含以下相应的包。1、java.time包：这是新的Java日期/时间API的基础包，所有的主要基础类都是这个包的一部分，如：LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration等等。所有这些类都是不可变的和线程安全的，在绝大多数情况下，这些类能够有效地处理一些公共的需求。2、java.time.chrono包：这个包为非ISO的日历系统定义了一些泛化的API，我们可以扩展AbstractChronology类来创建自己的日历系统。3、java.time.format包：这个包包含能够格式化和解析日期时间对象的类，在绝大多数情况下，我们不应该直接使用它们，因为java.time包中相应的类已经提供了格式化和解析的方法。4、java.time.temporal包：这个包包含一些时态对象，我们可以用其找出关于日期/时间对象的某个特定日期或时间，比如说，可以找到某月的第一天或最后一天。你可以非常容易地认出这些方法，因为它们都具有“withXXX”的格式。5、java.time.zone包：这个包包含支持不同时区以及相关规则的类。 Java日期/时间API示例如何在java8中获取当天的日期java8中有个叫LocalDate的类，能用来表示今天的日期。这个类与java.util.Date略有不同，因为它只包含日期，没有时间。 LocalDate today = LocalDate.now(); -- 2017-09-19 如何在java8中获取当前的年月日LocalDate类中提供了一些很方便的方法可以用来提取年月日以及其他的日期属性,特别方便，只需要使用对应的getter方法就可以了，非常直观。 LocalDate today = LocalDate.now(); int year = today.getYear(); int month = today.getMonthValue(); int day = today.getDayOfMonth(); System.out.println(year); System.out.println(month); System.out.println(day); 在java8中如何获取某个特定的日期通过另一个方法，可以创建出任意一个日期，它接受年月日的参数，然后返回一个等价的LocalDate实例。在这个方法里，需要的日期你填写什么就是什么，不想之前的API中月份必须从0开始。 LocalDate birthDay = LocalDate.of(2001, 1, 1); System.out.println(birthDay); 在java8中检查两个日期是否相等LocalDate重写了equals方法来进行日期的比较。 LocalDate todayEq = LocalDate.of(2017,9,19); System.out.println(todayEq.equals(today)); 在java8中如何检查重复事件，比如生日在java中还有一个与时间日期相关的任务就是检查重复事件，比如每月的账单日如何在java中判断是否是某个节日或者重复事件，使用MonthDay类。这个类由月日组合，不包含年信息，可以用来代表每年重复出现的一些日期或其他组合。他和新的日期库中的其他类一样也都是不可变且线程安全的，并且它还是一个值类（value class）。 MonthDay birth_Day = MonthDay.of(9,19); MonthDay to_Day = MonthDay.from(today); if(birth_Day.equals(to_Day)) { System.out.println(&quot;今天是你的生日&quot;); }else { System.out.println(&quot;今天不是你的生日&quot;); } 如何在java8中获取当前时间这个与第一个例子获取当前日期非常相似，这里用的是LocalTime类，默认的格式是hh:mm:ss:nnn LocalTime now = LocalTime.now(); System.out.println(now); --- 17:42:53.966 如何增加时间里面的小时数很多时候需要对时间进行操作，比如加一个小时来计算之后的时间，java8提供了更方便的方法 如plusHours，这些方法返回的是一个新的LocalTime实例的引用，因为LocalTime是不可变的。 LocalTime now = LocalTime.now(); System.out.println(&quot;当前时间：&quot; + now); LocalTime two = now.plusHours(2); System.out.println(&quot;2小时后的时间：&quot; + two); --- 当前时间：17:45:12.091 2小时后的时间：19:45:12.091 在java8中使用时钟java8自带了Clock类，可以用来获取某个时区下（所以对时区是敏感的）当前的瞬时时间、日期。用来代替System.currentTimelnMillis()与TimeZone.getDefault()方法。 Clock clock = Clock.systemUTC(); System.out.println(clock); -- SystemClock[Z] 在java中如何判断某个日期在另一个日期的前面还是后面如何判断某个日期在另一个日期的前面还是后面或者相等，在java8中，LocalDate类中使用isBefore()、isAfter()、equals()方法来比较两个日期。如果调用方法的那个日期比给定的日期要早的话，isBefore()方法会返回true。equals()方法在前面的例子中已经说明了。 LocalTime now = LocalTime.now(); System.out.println(&quot;当前时间：&quot; + now); LocalTime two = now.plusHours(2); System.out.println(&quot;2小时后的时间：&quot; + two); System.out.println(now.isBefore(two)); --- 当前时间：17:49:21.295 2小时后的时间：19:49:21.295 true 在java8中处理不同的时区java8中不仅将日期和时间进行了分离，同时还有时区。比如ZonId代表的是某个特定时区，ZonedDateTime代表带时区的时间，等同于以前的GregorianCalendar类。使用该类，可以将本地时间转换成另一个时区中的对应时间。 LocalDateTime localDateTime = LocalDateTime.now(); ZoneId zone = ZoneId.of(ZoneId.SHORT_IDS.get(&quot;ACT&quot;)); ZonedDateTime zdt = ZonedDateTime.of(localDateTime, zone); System.out.println(&quot;特定时区时间为：&quot; + zdt); --- 特定时区时间为：2017-09-19T17:59:10.288+09:30[Australia/Darwin] 如何表示固定的日期，比如信用卡过期时间正如MonthDay表示的是某个重复出现的日子，YearMonth是另外一个组合，代表的是像信用卡还款日，定期存款到期日，options到期日这类的日期。你可以用这个类找出这个月有多少天，LengthOfMonth()这个方法返回的是这个YearMonth实例有多少天，这对于检查2月是否润2月很有用。 YearMonth currentYearMonth = YearMonth.now(); System.out.printf(&quot;这个月的是%s有%d天&quot;,currentYearMonth,currentYearMonth.lengthOfMonth()); System.out.println( &quot;currentYearMonth.atEndOfMonth()：&quot; + currentYearMonth.atEndOfMonth()); YearMonth creditCartExpiry = YearMonth.of(2018, Month.OCTOBER); System.out.printf(&quot;你选择的年月日期是%s %n &quot;,creditCartExpiry); --- 这个月的是2017-09有30天 currentYearMonth.atEndOfMonth()：2017-09-30 你选择的年月日期是2018-10 如何在java8中检查闰年LocalDate类由一个isLeapYear()方法来返回当前LocalDate对应的那年是否是闰年。 LocalDate today = LocalDate.now(); System.out.println(today.isLeapYear()); --- false 计算两个日期之间包含多少天，多少月计算两个日期之间包含多少天、周、月、年。可以用java.time.Period类完成该功能。下面例子中将计算日期与将来的日期之间一共有几个月。 LocalDate today = LocalDate.now(); LocalDate date1 = LocalDate.of(2017, Month.JULY, 12); Period period= Period.between(today, date1); System.out.println(period.getDays()); System.out.println(period.getMonths()); --- -7 -2 在java8中获取当前时间戳java8获取时间戳特别简单。Instant类由一个静态的工厂方法now()可以返回当前时间戳 Instant it = Instant.now(); System.out.println(it); 可以看到，当前时间戳是包含日期和时间的，与java.util.Date很类似，事实上Instant就是java8以前的Date，可以使用这个两个类中的方法在这两个类型之间进行转换，比如Date.from(Instant)就是用来把Instant转换成java.util.date的，而Date。toInstant()就是将Date转换成Instant的 如何在java8中使用预定义的格式器来对日期进行解析/格式化在java8之前，时间日期的格式化非常麻烦，经常使用SimpleDateFormat来进行格式化，但是SimpleDateFormat并不是线程安全的。在java8中，引入了一个全新的线程安全的日期与时间格式器。并且预定义好了格式。比如，本例中使用的BASICISODATE格式会将20160414格式化成2016-04-14 String day = &quot;20130923&quot;; LocalDate formatterd = LocalDate.parse(day, DateTimeFormatter.BASIC_ISO_DATE); System.out.println(formatterd); --- 2013-09-23 如何在java中使用自定义的格式器来解析日期 在上例中，我们使用了预置的时间日期格式器来解析日期字符串了，但是有时预置的不能满足的时候就需要我们自定义日期格式器了，下面的例子中的日期格式是”MM dd yyyy”.你可以给DateTimeFormatter的ofPattern静态方法()传入任何的模式，它会返回一个实例，这个模式的字面量与前例中是相同的。比如M代表月，m仍代表分，无效的模式会抛异常DateTimeParseException。 String day1 = &quot;2013 09 23&quot;; try { DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;); LocalDate holiday = LocalDate.parse(day1,df); System.out.println(holiday); } catch (DateTimeParseException e) { // TODO: handle exception } --- 2013-09-23 如何在java8中对日期进行格式化，转换成字符串 前面的两个例子中，我们主要是对日期字符串来进行解析转换成日期，在这个例子我们相反，是把日期转换成字符。这里我们有个LocalDateTime类的实例，我们要把他转换成一个格式化好的日期串，与前例相同的是，我们仍需要制定模式串去创建一个DateTimeFormatter类的实例，但调用的是LocalDate.format()。这个方法会返回一个代表当前日期的字符串，对应的模式就是传入的DateTimeFormatter实例中定义好的。 LocalDateTime aDate = LocalDateTime.now(); try { DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;); System.out.println(aDate.format(df)); } catch (Exception e) { // TODO: handle exception } --- 2017 09 19]]></content>
      <categories>
        <category>java</category>
        <category>java8</category>
      </categories>
      <tags>
        <tag>Java8 日期/时间工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 中的 Streams API 详解]]></title>
    <url>%2F2017%2F09%2F19%2FJava8-%E4%B8%AD%E7%9A%84Streams%20API%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[为什么需要 StreamStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。 什么是聚合操作在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如： 客户每月平均消费金额最昂贵的在售商品本周完成的有效订单（排除了无效的）取十个数据样本作为首页推荐 这类的操作。但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：清单 1. Java 7 的排序、取值实现 List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;(); for(Transaction t: transactions){ if(t.getType() == Transaction.GROCERY){ groceryTransactions.add(t); } } Collections.sort(groceryTransactions, new Comparator(){ public int compare(Transaction t1, Transaction t2){ return t2.getValue().compareTo(t1.getValue()); } }); List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;(); for(Transaction t: groceryTransactions){ transactionsIds.add(t.getId()); } 而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。清单 2. Java 8 的排序、取值实现 List&lt;Integer&gt; transactionsIds = transactions.parallelStream(). filter(t -&gt; t.getType() == Transaction.GROCERY). sorted(comparing(Transaction::getValue).reversed()). map(Transaction::getId). collect(toList()); Stream 总览什么是流Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下： 1.0-1.4 中的 java.lang.Thread5.0 中的 java.util.concurrent6.0 中的 Phasers 等7.0 中的 Fork/Join 框架8.0 中的 Lambda Stream 的另外一大特点是，数据源本身可以是无限的。 流的构成当我们使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。图 1. 流管道 (Stream Pipeline) 的构成 有多种方式生成 Stream Source：从 Collection 和数组 Collection.stream() Collection.parallelStream() Arrays.stream(T array) or Stream.of() 从 BufferedReader java.io.BufferedReader.lines() 静态工厂 java.util.stream.IntStream.range() java.nio.file.Files.walk() 自己构建 java.util.Spliterator 其它 Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 流的操作类型分为两种：Intermediate 一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 Terminal 一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。还有一种操作被称为short-circuiting用以指 对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。 清单 3. 一个流操作的示例 int sum = widgets.stream() .filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum(); stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。 流的使用详解简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 流的构造与转换下面提供最常见的几种构造 Stream 的样例。 构造流的几种常见方法// 1. Individual values Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); // 2. Arrays String [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; stream = Stream.of(strArray); stream = Arrays.stream(strArray); // 3. Collections List&lt;String&gt; list = Arrays.asList(strArray); stream = list.stream(); 需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：IntStream、LongStream、DoubleStream。当然我们也可以用 Stream、Stream &gt;、Stream，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。 数值流的构造IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println); IntStream.range(1, 3).forEach(System.out::println); IntStream.rangeClosed(1, 3).forEach(System.out::println); 流转换为其它数据结构// 1. Array String[] strArray1 = stream.toArray(String[]::new); // 2. Collection List&lt;String&gt; list1 = stream.collect(Collectors.toList()); List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new)); Set set1 = stream.collect(Collectors.toSet()); Stack stack1 = stream.collect(Collectors.toCollection(Stack::new)); // 3. String String str = stream.collect(Collectors.joining()).toString(); 一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。 流的操作接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。 Intermediate map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered Terminal forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator Short-circuiting anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 我们下面看一下 Stream 的比较典型用法。 map/flatMap我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。转换大写 List&lt;String&gt; output = wordList.stream(). map(String::toUpperCase). collect(Collectors.toList()); 这段代码把所有的单词转换为大写。 平方数 List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4); List&lt;Integer&gt; squareNums = nums.stream(). map(n -&gt; n * n). collect(Collectors.toList()); 这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。一对多 Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) ); Stream&lt;Integer&gt; outputStream = inputStream. flatMap((childList) -&gt; childList.stream()); flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。 filterfilter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。留下偶数 Integer[] sixNums = {1, 2, 3, 4, 5, 6}; Integer[] evens = Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new); 经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。把单词挑出来 List&lt;String&gt; output = reader.lines(). flatMap(line -&gt; Stream.of(line.split(REGEXP))). filter(word -&gt; word.length() &gt; 0). collect(Collectors.toList()); 这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。 forEachforEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。打印姓名（forEach 和 pre-java8 的对比） // Java 8 roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName())); // Pre-Java 8 for (Person p : roster) { if (p.getGender() == Person.Sex.MALE) { System.out.println(p.getName()); } } 对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的： stream.forEach(element -&gt; doOneThing(element)); stream.forEach(element -&gt; doAnotherThing(element)); 相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。 peek 对每个元素执行操作并返回一个新的 Stream Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e)) .collect(Collectors.toList()); forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 findFirst这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。 Optional 的两个用例 String strA = &quot; abcd &quot;, strB = null; print(strA); print(&quot;&quot;); print(strB); getLength(strA); getLength(&quot;&quot;); getLength(strB); public static void print(String text) { // Java 8 Optional.ofNullable(text).ifPresent(System.out::println); // Pre-Java 8 if (text != null) { System.out.println(text); } } public static int getLength(String text) { // Java 8 return Optional.ofNullable(text).map(String::length).orElse(-1); // Pre-Java 8 // return if (text != null) ? text.length() : -1; }; 在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。 reduce这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于 Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或 Integer sum = integers.reduce(0, Integer::sum); 也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。 reduce 的用例 // 字符串连接，concat = &quot;ABCD&quot; String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); // 求最小值，minValue = -3.0 double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值 int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum); // 求和，sumValue = 10, 无起始值 sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get(); // 过滤，字符串连接，concat = &quot;ace&quot; concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat); 上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。 limit/skiplimit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。limit 和 skip 对运行次数的影响 public void testLimitAndSkip() { List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 10000; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); } List&lt;String&gt; personList2 = persons.stream(). map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); System.out.println(personList2); } private class Person { public int no; private String name; public Person (int no, String name) { this.no = no; this.name = name; } public String getName() { System.out.println(name); return name; } } 输出结果为： name1name2name3name4name5name6name7name8name9name10[name4, name5, name6, name7, name8, name9, name10] 这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。 limit 和 skip 对 sorted 后的运行次数无影响 List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); } List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList()); System.out.println(personList2); 上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为： name2name1name3name2name4name3name5name4[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27] 即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。 sorted对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：清单 18. 优化：排序前进行 limit 和 skip List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); } List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList()); System.out.println(personList2); 结果会简单很多： name2name1[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a] 当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。 min/max/distinctmin 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。找出最长一行的长度 BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;)); int longest = br.lines(). mapToInt(String::length). max(). getAsInt(); br.close(); System.out.println(longest); 下面的例子则使用 distinct 来找出不重复的单词。找出全文的单词，转小写，并排序 List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList()); br.close(); System.out.println(words); MatchStream 有三个 match 方法，从语义上说：allMatch：Stream 中全部元素符合传入的 predicate，返回 trueanyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 truenoneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。使用 Match List&lt;Person&gt; persons = new ArrayList(); persons.add(new Person(1, &quot;name&quot; + 1, 10)); persons.add(new Person(2, &quot;name&quot; + 2, 21)); persons.add(new Person(3, &quot;name&quot; + 3, 34)); persons.add(new Person(4, &quot;name&quot; + 4, 6)); persons.add(new Person(5, &quot;name&quot; + 5, 55)); boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18); System.out.println(&quot;All are adult? &quot; + isAllAdult); boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12); System.out.println(&quot;Any child? &quot; + isThereAnyChild); 输出结果： All are adult? falseAny child? true 进阶：自己生成流Stream.generate通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。生成 10 个随机整数 Random seed = new Random(); Supplier&lt;Integer&gt; random = seed::nextInt; Stream.generate(random).limit(10).forEach(System.out::println); //Another way IntStream.generate(() -&gt; (int) (System.nanoTime() % 100)). limit(10).forEach(System.out::println); Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。 自实现 Supplier Stream.generate(new PersonSupplier()). limit(10). forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge())); private class PersonSupplier implements Supplier&lt;Person&gt; { private int index = 0; private Random random = new Random(); @Override public Person get() { return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100)); } } 输出结果： StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76 ##Stream.iterateiterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。24. 生成一个等差数列 Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));. 输出结果： 10 3 6 9 12 15 18 21 24 27 与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。 进阶：用 Collectors 来进行 reduction 操作java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。groupingBy/partitioningBy按照年龄归组 Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge)); Iterator it = personGroups.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size()); } 上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出： Age 0 = 2Age 1 = 2Age 5 = 2Age 8 = 1Age 9 = 1Age 11 = 2…… 按照未成年人和成年人归组 Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18)); System.out.println(&quot;Children number: &quot; + children.get(true).size()); System.out.println(&quot;Adult number: &quot; + children.get(false).size()); 输出结果： Children number: 23Adult number: 77 在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。 #结束语总之，Stream 的特性可以归纳为： 不是数据结构 它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。 它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 所有 Stream 的操作必须以 lambda 表达式为参数 不支持索引访问你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。很容易生成数组或者 List 惰性化很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。 并行能力当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 可以是无限的集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。]]></content>
      <categories>
        <category>java</category>
        <category>java8</category>
      </categories>
      <tags>
        <tag>Java8 Streams java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻松学习新代码库的六个步骤]]></title>
    <url>%2F2017%2F09%2F09%2F%E8%BD%BB%E6%9D%BE%E5%AD%A6%E4%B9%A0%E6%96%B0%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E5%85%AD%E4%B8%AA%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[学习新的代码库是一项艰巨的任务。如果你不能和创建该库的研发人员进行交流，自己研究该库是一个很复杂的过程。本文给出六个步骤指引开发者学习。 步骤一：创建业务词汇表单如果你是一位开发者，你或许会出席过一些软件设计会议，会议可能会涉及到创建新术语，以便于更好的软件设计交流。在创建该术语的同时可能会发生与该术语同义的情况，会议成员不可避免地讨论这些具有相同概念的术语，这会让人感到混乱。 这时，业务词汇表单就变得尤为重要，它能记录这些新的术语。在软件设计的每个阶段，你会不断碰到新的术语和概念。把这些术语保存起来非常重要，并且边学边存储，绝对有益无害。 业务词汇表单应该包含几个不同的列，分别是：“术语名称”、“语境”、“定义”。当你看到一个有趣的术语和短语时，可以更新该表单。该表单有可能包含大量的同义词，也有可能有对同一术语的不同定义解释。出现上述的情况，你需要结合上下文的语境进行分析使用。 步骤二：了解应用程序运行应用程序并且获知该程序提供的功能。如果你不知道该程序是做什么的，就无法在源代码中寻找有关信息。 步骤三：浏览有效的类库文档迄今为止，是不是任何的体系结构或设计类库文档的内容都是合理呢？这有待考量。类库文档是一个极好的资源。如果旧的体系架构已经历了数次修订，它就不再值得你花时间去阅读整个文档，不过，你可以大概浏览一下。如果你足够幸运，你可以在文档中遇到你所需的术语。 步骤四：做假设几乎所有的应用程序中，开发者都会碰到如下情况：环境的配置、I18N（语言的国际化）、应用程序的文件格式、用户界面、应用程序的启动和关闭。针对这些情况，可以进行假设。开发者可以假设应用程序中的任何一段代码块，哪个代码块是应用程序的核心，这个才是学习的重点。 步骤 五：定位第三方库文件代码库很有可能存在一些的依赖。如果检查到项目中包含第三方库文件，可以查看该库文件是如何与应用程序的功能联系起来的，某处的模块或组件是如何使用第三方库的。 步骤六：分析代码本部分列举几个选项来分析新的代码库： 1、目录以及文件架构可以把目录名中的一些术语添加到业务词汇表单中。文件架构可以提供一些基本的线索，如：前台代码及后台代码。它们可以分别放在独立的文件中。开发者会发现，凡具有特定功能的模块代码都被放在独立的文件夹中。按照这个线索，就知道如何进行查找了。 2、功能文件的映射在用户界面上写一些可执行的功能代码块。把重要的代码块放到一个单独的文件夹中，并对文件夹进行命名。这个文件夹有可能对团队中的其他人有用，他们可以把该功能应用到项目编程中。 3、单元测试如果采用单元测试，开发者可能会用到第三方框架。你可以用第三方框架来辅助测试。即使没有找到合适的框架，仍然可以来做单元测试。当然，你也可以不采用单元测试，但我依然推荐你用，因为有助于你对源代码中组件的理解。 4、注释源代码中可能包含一些注释，有的注释对开发人员很有帮助，有的会让人有所误导或有的注释可能过期了。如果你觉得注释有问题，你可以通过调试器追踪有关代码，了解相关代码的意思。如果你发现错误的注释，修改或删除它们。 5、可视化工具在新的代码库中使用语言代码分析工具。如：ObjectAid是一个极好的Java代码分析工具。这是 Eclipse IDE中的一个插件。你可以创建对象来协助类图，把java文件拉到类图中，就自动画出类图。 6、设置断点使用调试器，设置一些断点并运行查看。这是第一次学习新的代码基础。 结论上述的分析过程采用自上而下的方法，能够更好的帮助开发者学习新的代码库。]]></content>
      <tags>
        <tag>源码学习 架构师之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式定时任务调度系统技术选型]]></title>
    <url>%2F2017%2F08%2F15%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[我们先思考下面几个业务场景的解决方案: 支付系统每天凌晨1点跑批，进行一天清算，每月1号进行上个月清算 电商整点抢购，商品价格8点整开始优惠 12306购票系统，超过30分钟没有成功支付订单的，进行回收处理 商品成功发货后，需要向客户发送短信提醒 类似的业务场景非常多，我们怎么解决？ 为什么我们需要定时任务很多业务场景需要我们某一特定的时刻去做某件任务，定时任务解决的就是这种业务场景。一般来说，系统可以使用消息传递代替部分定时任务，两者有很多相似之处，可以相互替换场景。如，上面发货成功发短信通知客户的业务场景，我们可以在发货成功后发送MQ消息到队列，然后去消费mq消息，发送短信。但在某些场景下不能互换： a)时间驱动/事件驱动：内部系统一般可以通过时间来驱动，但涉及到外部系统，则只能使用时间驱动。如怕取外部网站价格，每小时爬一次b)批量处理/逐条处理：批量处理堆积的数据更加高效，在不需要实时性的情况下比消息中间件更有优势。而且有的业务逻辑只能批量处理。如移动每个月结算我们的话费c)实时性/非实时性：消息中间件能够做到实时处理数据，但是有些情况下并不需要实时，比如：vip升级d)系统内部/系统解耦：定时任务调度一般是在系统内部，而消息中间件可用于两个系统间 java有哪些定时任务的框架单机 timer：是一个定时器类，通过该类可以为指定的定时任务进行配置。TimerTask类是一个定时任务类，该类实现了Runnable接口，缺点异常未检查会中止线程 ScheduledExecutorService：相对延迟或者周期作为定时任务调度，缺点没有绝对的日期或者时间 spring定时框架：配置简单功能较多，如果系统使用单机的话可以优先考虑spring定时器 分布 Quartz：Java事实上的定时任务标准。但Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能 TBSchedule：阿里早期开源的分布式任务调度系统。代码略陈旧，使用timer而非线程池执行任务调度。众所周知，timer在处理异常状况时是有缺陷的。而且TBSchedule作业类型较为单一，只能是获取/处理数据一种模式。还有就是文档缺失比较严重 elastic-job：当当开发的弹性分布式任务调度系统，功能丰富强大，采用zookeeper实现分布式协调，实现任务高可用以及分片，目前是版本2.15，并且可以支持云开发 Saturn：是唯品会自主研发的分布式的定时任务的调度平台，基于当当的elastic-job 版本1开发，并且可以很好的部署到docker容器上。 xxl-job: 是大众点评员工徐雪里于2015年发布的分布式任务调度平台，是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。 分布式任务调度系统对比 参与对比的可选系统方案： elastic——job （以下简称E-Job）与 xxx-job(以下简称X-Job) 项目背景及社区力量X-Job ： 大众点评公司下员工许雪里、贡献者 3人; github有2470star、1015fork | QQ讨论群6个 | 有登记在使用的超过40家公司 | 文档齐全E-Job ： 当当网开源，贡献者17人; github有2524star、1015fork | QQ讨论群１个、源码讨论群１个 | 有登记在使用的超过50家公司 | 文档齐全 ｜ 有明确的发展计划 支持集群部署X-Job ： 集群部署唯一要求为：保证每个集群节点配置（db和登陆账号等）保持一致。调度中心通过db配置区分不同集群。 执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。集群部署唯一要求为：保证集群中每个执行器的配置项 “xxl.job.admin.addresses/调度中心地址” 保持一致，执行器根据该配置进行执行器自动注册等操作。 E-Job ： 重写Quartz基于数据库的分布式功能，改用Zookeeper实现注册中心 作业注册中心： 基于Zookeeper和其客户端Curator实现的全局作业注册控制中心。用于注册，控制和协调分布式作业执行。 多节点部署时任务不能重复执行X-Job ： 使用Quartz基于数据库的分布式功能E-Job ： 将任务拆分为n个任务项后，各个服务器分别执行各自分配到的任务项。一旦有新的服务器加入集群，或现有服务器下线，elastic-job将在保留本次任务执行不变的情况下，下次任务开始前触发任务重分片。 日志可追溯X-Job ： 支持，有日志查询界面E-Job ： 可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job目前提供了基于关系型数据库两种事件订阅方式记录事件。 监控告警X-Job ： 调度失败时，将会触发失败报警，如发送报警邮件。 任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔 E-Job ： 通过事件订阅方式可自行实现 作业运行状态监控、监听作业服务器存活、监听近期数据处理成功、数据流类型作业（可通过监听近期数据处理成功数判断作业流量是否正常,如果小于作业正常处理的阀值，可选择报警。）、监听近期数据处理失败（可通过监听近期数据处理失败数判断作业处理结果，如果大于0，可选择报警。） 弹性扩容缩容X-Job ： 使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力E-Job ： 通过zk实现各服务的注册、控制及协调 支持并行调度X-Job ： 调度系统多线程（默认10个线程）触发调度运行，确保调度精确执行，不被堵塞。E-Job ： 采用任务分片方式实现。将一个任务拆分为n个独立的任务项，由分布式的服务器并行执行各自分配到的分片项。 高可用策略X-Job ： “调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；E-Job ： 调度器的高可用是通过运行几个指向同一个ZooKeeper集群的Elastic-Job-Cloud-Scheduler实例来实现的。ZooKeeper用于在当前主Elastic-Job-Cloud-Scheduler实例失败的情况下执行领导者选举。通过至少两个调度器实例来构成集群，集群中只有一个调度器实例提供服务，其他实例处于”待命”状态。当该实例失败时，集群会选举剩余实例中的一个来继续提供服务。 失败处理策略X-Job ： 调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；E-Job ： 弹性扩容缩容在下次作业运行前重分片，但本次作业执行的过程中，下线的服务器所分配的作业将不会重新被分配。失效转移功能可以在本次作业运行中用空闲服务器抓取孤儿作业分片执行。同样失效转移功能也会牺牲部分性能。 动态分片策略X-Job ： 分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。 执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务； E-Job ： 支持多种分片策略，可自定义分片策略 默认包含三种分片策略： 基于平均分配算法的分片策略、 作业名的哈希值奇偶数决定IP升降序算法的分片策略、根据作业名的哈希值对Job实例列表进行轮转的分片策略，支持自定义分片策略 elastic-job的分片是通过zookeeper来实现的。分片的分片由主节点分配，如下三种情况都会触发主节点上的分片算法执行：a、新的Job实例加入集群b、现有的Job实例下线（如果下线的是leader节点，那么先选举然后触发分片算法的执行）c、主节点选举” 和quartz框架对比 调用API的的方式操作任务，不人性化； 需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。 调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务； Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。 综合对比 总结和结论 共同点： E-Job和X-job都有广泛的用户基础和完整的技术文档，都能满足定时任务的基本功能需求。 不同点 X-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用 E-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用 附 定时任务的其他方案发货后超过10天未收货时系统自动确认收货的多种实现方式 每天定时半夜筛选第二天 可以自动确认收货的订单,然后第二天 每10分钟 执行一次确认收货 开销不会太大吧 时间也相对精确 自动确认收货这个状态如果仅仅是让客户端看的话，等用户下一次上线的时间，做一次运算就可以了。 延迟和定时消息投递ActiveMQ提供了一种broker端消息定时调度机制。适用于：1、不希望消息马上被broker投递出去，而是想要消息60秒以后发给消费者，2、想让消息没隔一定时间投递一次，一共投递指定的次数RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter。利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。]]></content>
      <categories>
        <category>微服务</category>
        <category>定时任务</category>
      </categories>
      <tags>
        <tag>分布式架构</tag>
        <tag>微服务</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计6大原则]]></title>
    <url>%2F2017%2F08%2F11%2FJava%E8%AE%BE%E8%AE%A16%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[所谓无招胜有招，练一门功夫分为内功和外功。外功好比招式，就是所谓的23种设计模式。而内功呢，就是心法，那就是这6种法则。光会外功那是花拳绣腿，内功修为才是境界。如此众多的设计模式，学完2遍，3遍可能也会忘的只记得单例和工厂模式。但是只要原则记住，在以后的设计中，有意无意就会用的设计模式的精髓。一 ： 类单一职责原则： 一个类只有一个引起这个类变化的原因。即一个类只完成一个功能，如果做不到一个类只完成一个功能，最少要保证一个方法只完成一个功能。 二：依赖倒置原则： 高层组件应该依赖抽象而不依赖具体，即面向接口编程，一般依赖的成员变量或者参数都应该是抽象的不应该是具体的。 三：里氏代换原则： 凡是父类出现的地方都可以用子类代替并且原功能没有发生变化，子类不应该覆盖父类的非抽象方法。 四：迪米特法则： 一个类要尽量的封装自己，一个类只与自己的朋友类打交道一般朋友类是成员变量或者参数，非朋友类一般都是局部变量 五：接口隔离原则： 一个接口完成的功能尽可能的单一，不要让一个接口承担过多的责任。 六：开闭原则： 对扩展开放，对修改闭合]]></content>
      <tags>
        <tag>Java设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[领域驱动设计原理]]></title>
    <url>%2F2017%2F08%2F06%2F%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[使用领域驱动设计的业务价值1、你获得了一个非常有用的领域模型2、你的业务得到了更准确的定义和理解3、领域专家可以为软件设计做出贡献4、更好的用户体验5、清晰的模型边界6、更好的企业架构7、敏捷、迭代式和持续建模8、使用战略和战术新工具 领域驱动设计参考项目推荐1.IDDD_Samples实现领域驱动设计作者VaughnVernon 所做的四种不同实现https://github.com/VaughnVernon/IDDD_Samples 2.dddsample-core领域驱动设计(Domain Driven Design)的官方参考架构，该架构分成了Interfaces、Applications和Domain三层以及包含各类基础设施的Infrastructure。https://github.com/citerus/dddsample-core 3.Axon-trader基于命令查询职责分离(CQRS)模式的一种领域驱动实现https://github.com/AxonFramework/Axon-trader，依赖框架 https://github.com/AxonFramework/AxonFramework其中有整合disruptor的实现的命令总线和自身的命令总线。Disruptor是一个高性能的异步处理框架，或者可以认为是最快的消息框架(轻量的JMS)，也可以认为是一个观察者模式实现，或者事件-监听模式的实现，直接称disruptor模式。disruptor最大特点是高性能，其LMAX架构可以获得每秒6百万订单，用1微秒的延迟获得吞吐量为100K+。 《领域驱动设计模式、原理与实践》 整理思维导图]]></content>
      <categories>
        <category>领域驱动设计</category>
        <category>模式、原理与实践</category>
      </categories>
      <tags>
        <tag>领域驱动设计</tag>
        <tag>领域驱动设计模式</tag>
        <tag>领域驱动设计原理与实践</tag>
      </tags>
  </entry>
</search>
