<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EFbiz</title>
  <subtitle>Everything For business</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/efbiz/"/>
  <updated>2017-09-19T10:34:27.320Z</updated>
  <id>https://github.com/efbiz/</id>
  
  <author>
    <name>joni@efbiz.org</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8 日期/时间（Date Time）API指南</title>
    <link href="https://github.com/efbiz/2017/09/19/Java8-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%EF%BC%88Date-Time%EF%BC%89API%E6%8C%87%E5%8D%97/"/>
    <id>https://github.com/efbiz/2017/09/19/Java8-日期-时间（Date-Time）API指南/</id>
    <published>2017-09-19T08:39:51.000Z</published>
    <updated>2017-09-19T10:34:27.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么我们需要新的Java日期-时间API？"><a href="#为什么我们需要新的Java日期-时间API？" class="headerlink" title="为什么我们需要新的Java日期/时间API？"></a>为什么我们需要新的Java日期/时间API？</h1><p>在开始研究Java 8日期/时间API之前，让我们先来看一下为什么我们需要这样一个新的API。在Java中，现有的与日期和时间相关的类存在诸多问题，其中有：<br>1、Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。<br>2、java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。<br>3、对于时间、时间戳、格式化以及解析，并没有一些明确定义的类。对于格式化和解析的需求，我们有java.text.DateFormat抽象类，但通常情况下，SimpleDateFormat类被用于此类需求。<br>4、所有的日期类都是可变的，因此他们都不是线程安全的，这是Java日期类最大的问题之一。<br>5、日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。<br>在现有的日期和日历类中定义的方法还存在一些其他的问题，但以上问题已经很清晰地表明：Java需要一个健壮的日期/时间类。这也是为什么Joda Time在Java日期/时间需求中扮演了高质量替换的重要角色。</p>
<a id="more"></a>
<h1 id="Java-8日期-时间API设计原则"><a href="#Java-8日期-时间API设计原则" class="headerlink" title="Java 8日期/时间API设计原则"></a>Java 8日期/时间API设计原则</h1><p>1、不变性：新的日期/时间API中，所有的类都是不可变的，这对多线程环境有好处。<br>2、关注点分离：新的API将人可读的日期时间和机器时间（unix timestamp）明确分离，它为日期（Date）、时间（Time）、日期时间（DateTime）、时间戳（unix timestamp）以及时区定义了不同的类。<br>3、清晰：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用now()方法，在所有的类中都定义了format()和parse()方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。<br>4、实用操作：所有新的日期/时间API类都实现了一系列方法用以完成通用的任务，如：加、减、格式化、解析、从日期/时间中提取单独部分，等等。<br>5、可扩展性：新的日期/时间API是工作在ISO-8601日历系统上的，但我们也可以将其应用在非IOS的日历上。</p>
<h1 id="Java日期-时间API包"><a href="#Java日期-时间API包" class="headerlink" title="Java日期/时间API包"></a>Java日期/时间API包</h1><p>Java日期/时间API包含以下相应的包。<br>1、java.time包：这是新的Java日期/时间API的基础包，所有的主要基础类都是这个包的一部分，如：LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration等等。所有这些类都是不可变的和线程安全的，在绝大多数情况下，这些类能够有效地处理一些公共的需求。<br>2、java.time.chrono包：这个包为非ISO的日历系统定义了一些泛化的API，我们可以扩展AbstractChronology类来创建自己的日历系统。<br>3、java.time.format包：这个包包含能够格式化和解析日期时间对象的类，在绝大多数情况下，我们不应该直接使用它们，因为java.time包中相应的类已经提供了格式化和解析的方法。<br>4、java.time.temporal包：这个包包含一些时态对象，我们可以用其找出关于日期/时间对象的某个特定日期或时间，比如说，可以找到某月的第一天或最后一天。你可以非常容易地认出这些方法，因为它们都具有“withXXX”的格式。<br>5、java.time.zone包：这个包包含支持不同时区以及相关规则的类。</p>
<h1 id="Java日期-时间API示例"><a href="#Java日期-时间API示例" class="headerlink" title="Java日期/时间API示例"></a>Java日期/时间API示例</h1><h2 id="如何在java8中获取当天的日期"><a href="#如何在java8中获取当天的日期" class="headerlink" title="如何在java8中获取当天的日期"></a>如何在java8中获取当天的日期</h2><p>java8中有个叫LocalDate的类，能用来表示今天的日期。这个类与java.util.Date略有不同，因为它只包含日期，没有时间。</p>
<pre><code>LocalDate today = LocalDate.now();
--
2017-09-19
</code></pre><h2 id="如何在java8中获取当前的年月日"><a href="#如何在java8中获取当前的年月日" class="headerlink" title="如何在java8中获取当前的年月日"></a>如何在java8中获取当前的年月日</h2><p>LocalDate类中提供了一些很方便的方法可以用来提取年月日以及其他的日期属性,特别方便，只需要使用对应的getter方法就可以了，非常直观。</p>
<pre><code>LocalDate today = LocalDate.now();
int year = today.getYear();
int month = today.getMonthValue();
int day = today.getDayOfMonth();
System.out.println(year);
System.out.println(month);
System.out.println(day);
</code></pre><h2 id="在java8中如何获取某个特定的日期"><a href="#在java8中如何获取某个特定的日期" class="headerlink" title="在java8中如何获取某个特定的日期"></a>在java8中如何获取某个特定的日期</h2><p>通过另一个方法，可以创建出任意一个日期，它接受年月日的参数，然后返回一个等价的LocalDate实例。在这个方法里，需要的日期你填写什么就是什么，不想之前的API中月份必须从0开始。</p>
<pre><code>LocalDate birthDay = LocalDate.of(2001, 1, 1);
System.out.println(birthDay);
</code></pre><h2 id="在java8中检查两个日期是否相等"><a href="#在java8中检查两个日期是否相等" class="headerlink" title="在java8中检查两个日期是否相等"></a>在java8中检查两个日期是否相等</h2><p>LocalDate重写了equals方法来进行日期的比较。</p>
<pre><code>LocalDate todayEq = LocalDate.of(2017,9,19);
System.out.println(todayEq.equals(today));
</code></pre><h2 id="在java8中如何检查重复事件，比如生日"><a href="#在java8中如何检查重复事件，比如生日" class="headerlink" title="在java8中如何检查重复事件，比如生日"></a>在java8中如何检查重复事件，比如生日</h2><p>在java中还有一个与时间日期相关的任务就是检查重复事件，比如每月的账单日<br>如何在java中判断是否是某个节日或者重复事件，使用MonthDay类。这个类由月日组合，不包含年信息，可以用来代表每年重复出现的一些日期或其他组合。他和新的日期库中的其他类一样也都是不可变且线程安全的，并且它还是一个值类（value class）。</p>
<pre><code>MonthDay birth_Day = MonthDay.of(9,19);
MonthDay to_Day = MonthDay.from(today);
if(birth_Day.equals(to_Day)) {
    System.out.println(&quot;今天是你的生日&quot;);
}else {
    System.out.println(&quot;今天不是你的生日&quot;);
}
</code></pre><h2 id="如何在java8中获取当前时间"><a href="#如何在java8中获取当前时间" class="headerlink" title="如何在java8中获取当前时间"></a>如何在java8中获取当前时间</h2><p>这个与第一个例子获取当前日期非常相似，这里用的是LocalTime类，默认的格式是hh:mm:ss:nnn    </p>
<pre><code>LocalTime now = LocalTime.now();
System.out.println(now);
---
17:42:53.966
</code></pre><h2 id="如何增加时间里面的小时数"><a href="#如何增加时间里面的小时数" class="headerlink" title="如何增加时间里面的小时数"></a>如何增加时间里面的小时数</h2><p>很多时候需要对时间进行操作，比如加一个小时来计算之后的时间，java8提供了更方便的方法 如plusHours，这些方法返回的是一个新的LocalTime实例的引用，因为LocalTime是不可变的。</p>
<pre><code>LocalTime now = LocalTime.now();
System.out.println(&quot;当前时间：&quot; + now);
LocalTime two = now.plusHours(2);
System.out.println(&quot;2小时后的时间：&quot; + two);
---
当前时间：17:45:12.091
2小时后的时间：19:45:12.091
</code></pre><h2 id="在java8中使用时钟"><a href="#在java8中使用时钟" class="headerlink" title="在java8中使用时钟"></a>在java8中使用时钟</h2><p>java8自带了Clock类，可以用来获取某个时区下（所以对时区是敏感的）当前的瞬时时间、日期。用来代替System.currentTimelnMillis()与TimeZone.getDefault()方法。</p>
<pre><code>Clock clock = Clock.systemUTC();
System.out.println(clock);
--
SystemClock[Z]
</code></pre><h2 id="在java中如何判断某个日期在另一个日期的前面还是后面"><a href="#在java中如何判断某个日期在另一个日期的前面还是后面" class="headerlink" title="在java中如何判断某个日期在另一个日期的前面还是后面"></a>在java中如何判断某个日期在另一个日期的前面还是后面</h2><p>如何判断某个日期在另一个日期的前面还是后面或者相等，在java8中，LocalDate类中使用isBefore()、isAfter()、equals()方法来比较两个日期。如果调用方法的那个日期比给定的日期要早的话，isBefore()方法会返回true。equals()方法在前面的例子中已经说明了。</p>
<pre><code>LocalTime now = LocalTime.now();
System.out.println(&quot;当前时间：&quot; + now);
LocalTime two = now.plusHours(2);
System.out.println(&quot;2小时后的时间：&quot; + two);
System.out.println(now.isBefore(two));
---
当前时间：17:49:21.295
2小时后的时间：19:49:21.295
true
</code></pre><h2 id="在java8中处理不同的时区"><a href="#在java8中处理不同的时区" class="headerlink" title="在java8中处理不同的时区"></a>在java8中处理不同的时区</h2><p>java8中不仅将日期和时间进行了分离，同时还有时区。比如ZonId代表的是某个特定时区，ZonedDateTime代表带时区的时间，等同于以前的GregorianCalendar类。使用该类，可以将本地时间转换成另一个时区中的对应时间。</p>
<pre><code>LocalDateTime localDateTime = LocalDateTime.now();
ZoneId zone = ZoneId.of(ZoneId.SHORT_IDS.get(&quot;ACT&quot;));
ZonedDateTime zdt = ZonedDateTime.of(localDateTime, zone);
System.out.println(&quot;特定时区时间为：&quot; + zdt);
---
特定时区时间为：2017-09-19T17:59:10.288+09:30[Australia/Darwin]
</code></pre><h2 id="如何表示固定的日期，比如信用卡过期时间"><a href="#如何表示固定的日期，比如信用卡过期时间" class="headerlink" title="如何表示固定的日期，比如信用卡过期时间"></a>如何表示固定的日期，比如信用卡过期时间</h2><p>正如MonthDay表示的是某个重复出现的日子，YearMonth是另外一个组合，代表的是像信用卡还款日，定期存款到期日，options到期日这类的日期。你可以用这个类找出这个月有多少天，LengthOfMonth()这个方法返回的是这个YearMonth实例有多少天，这对于检查2月是否润2月很有用。</p>
<pre><code>YearMonth currentYearMonth = YearMonth.now();
System.out.printf(&quot;这个月的是%s有%d天&quot;,currentYearMonth,currentYearMonth.lengthOfMonth());
System.out.println( &quot;currentYearMonth.atEndOfMonth()：&quot; + currentYearMonth.atEndOfMonth());
YearMonth creditCartExpiry = YearMonth.of(2018, Month.OCTOBER);
System.out.printf(&quot;你选择的年月日期是%s %n &quot;,creditCartExpiry);
---
这个月的是2017-09有30天
currentYearMonth.atEndOfMonth()：2017-09-30
你选择的年月日期是2018-10 
</code></pre><h2 id="如何在java8中检查闰年"><a href="#如何在java8中检查闰年" class="headerlink" title="如何在java8中检查闰年"></a>如何在java8中检查闰年</h2><p>LocalDate类由一个isLeapYear()方法来返回当前LocalDate对应的那年是否是闰年。</p>
<pre><code>LocalDate today = LocalDate.now();
System.out.println(today.isLeapYear());
---
 false
</code></pre><h2 id="计算两个日期之间包含多少天，多少月"><a href="#计算两个日期之间包含多少天，多少月" class="headerlink" title="计算两个日期之间包含多少天，多少月"></a>计算两个日期之间包含多少天，多少月</h2><p>计算两个日期之间包含多少天、周、月、年。可以用java.time.Period类完成该功能。下面例子中将计算日期与将来的日期之间一共有几个月。</p>
<pre><code>LocalDate today = LocalDate.now();
LocalDate date1 = LocalDate.of(2017, Month.JULY, 12);
Period period= Period.between(today, date1);
System.out.println(period.getDays());
System.out.println(period.getMonths());
---
-7
-2
</code></pre><h2 id="在java8中获取当前时间戳"><a href="#在java8中获取当前时间戳" class="headerlink" title="在java8中获取当前时间戳"></a>在java8中获取当前时间戳</h2><p>java8获取时间戳特别简单。Instant类由一个静态的工厂方法now()可以返回当前时间戳</p>
<pre><code>Instant it = Instant.now();
System.out.println(it);
</code></pre><p>可以看到，当前时间戳是包含日期和时间的，与java.util.Date很类似，事实上Instant就是java8以前的Date，可以使用这个两个类中的方法在这两个类型之间进行转换，比如Date.from(Instant)就是用来把Instant转换成java.util.date的，而Date。toInstant()就是将Date转换成Instant的</p>
<h2 id="如何在java8中使用预定义的格式器来对日期进行解析-格式化"><a href="#如何在java8中使用预定义的格式器来对日期进行解析-格式化" class="headerlink" title="如何在java8中使用预定义的格式器来对日期进行解析/格式化"></a>如何在java8中使用预定义的格式器来对日期进行解析/格式化</h2><p>在java8之前，时间日期的格式化非常麻烦，经常使用SimpleDateFormat来进行格式化，但是SimpleDateFormat并不是线程安全的。在java8中，引入了一个全新的线程安全的日期与时间格式器。并且预定义好了格式。比如，本例中使用的BASICISODATE格式会将20160414格式化成2016-04-14</p>
<pre><code>String day = &quot;20130923&quot;;
LocalDate formatterd = LocalDate.parse(day, DateTimeFormatter.BASIC_ISO_DATE);
System.out.println(formatterd);
---
2013-09-23
</code></pre><h2 id="如何在java中使用自定义的格式器来解析日期"><a href="#如何在java中使用自定义的格式器来解析日期" class="headerlink" title="如何在java中使用自定义的格式器来解析日期"></a>如何在java中使用自定义的格式器来解析日期</h2><p> 在上例中，我们使用了预置的时间日期格式器来解析日期字符串了，但是有时预置的不能满足的时候就需要我们自定义日期格式器了，下面的例子中的日期格式是”MM dd yyyy”.你可以给DateTimeFormatter的ofPattern静态方法()传入任何的模式，它会返回一个实例，这个模式的字面量与前例中是相同的。比如M代表月，m仍代表分，无效的模式会抛异常DateTimeParseException。</p>
<pre><code> String day1 = &quot;2013 09 23&quot;;
try {
    DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;);
    LocalDate holiday = LocalDate.parse(day1,df);
    System.out.println(holiday);
} catch (DateTimeParseException e) {
    // TODO: handle exception
}
---
2013-09-23
</code></pre><h2 id="如何在java8中对日期进行格式化，转换成字符串"><a href="#如何在java8中对日期进行格式化，转换成字符串" class="headerlink" title="如何在java8中对日期进行格式化，转换成字符串"></a>如何在java8中对日期进行格式化，转换成字符串</h2><p> 前面的两个例子中，我们主要是对日期字符串来进行解析转换成日期，在这个例子我们相反，是把日期转换成字符。这里我们有个LocalDateTime类的实例，我们要把他转换成一个格式化好的日期串，与前例相同的是，我们仍需要制定模式串去创建一个DateTimeFormatter类的实例，但调用的是LocalDate.format()。这个方法会返回一个代表当前日期的字符串，对应的模式就是传入的DateTimeFormatter实例中定义好的。</p>
<pre><code> LocalDateTime aDate = LocalDateTime.now();
try {
    DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;);
    System.out.println(aDate.format(df));
} catch (Exception e) {
    // TODO: handle exception
}
---
2017 09 19
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么我们需要新的Java日期-时间API？&quot;&gt;&lt;a href=&quot;#为什么我们需要新的Java日期-时间API？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们需要新的Java日期/时间API？&quot;&gt;&lt;/a&gt;为什么我们需要新的Java日期/时间API？&lt;/h1&gt;&lt;p&gt;在开始研究Java 8日期/时间API之前，让我们先来看一下为什么我们需要这样一个新的API。在Java中，现有的与日期和时间相关的类存在诸多问题，其中有：&lt;br&gt;1、Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。&lt;br&gt;2、java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。&lt;br&gt;3、对于时间、时间戳、格式化以及解析，并没有一些明确定义的类。对于格式化和解析的需求，我们有java.text.DateFormat抽象类，但通常情况下，SimpleDateFormat类被用于此类需求。&lt;br&gt;4、所有的日期类都是可变的，因此他们都不是线程安全的，这是Java日期类最大的问题之一。&lt;br&gt;5、日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。&lt;br&gt;在现有的日期和日历类中定义的方法还存在一些其他的问题，但以上问题已经很清晰地表明：Java需要一个健壮的日期/时间类。这也是为什么Joda Time在Java日期/时间需求中扮演了高质量替换的重要角色。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://github.com/efbiz/categories/java/"/>
    
      <category term="java8" scheme="https://github.com/efbiz/categories/java/java8/"/>
    
    
      <category term="Java8 日期/时间工具类" scheme="https://github.com/efbiz/tags/Java8-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>轻松学习新代码库的六个步骤</title>
    <link href="https://github.com/efbiz/2017/09/09/%E8%BD%BB%E6%9D%BE%E5%AD%A6%E4%B9%A0%E6%96%B0%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E5%85%AD%E4%B8%AA%E6%AD%A5%E9%AA%A4/"/>
    <id>https://github.com/efbiz/2017/09/09/轻松学习新代码库的六个步骤/</id>
    <published>2017-09-09T08:35:16.000Z</published>
    <updated>2017-09-09T08:38:33.878Z</updated>
    
    <content type="html"><![CDATA[<p>学习新的代码库是一项艰巨的任务。如果你不能和创建该库的研发人员进行交流，自己研究该库是一个很复杂的过程。本文给出六个步骤指引开发者学习。</p>
<a id="more"></a>
<h1 id="步骤一：创建业务词汇表单"><a href="#步骤一：创建业务词汇表单" class="headerlink" title="步骤一：创建业务词汇表单"></a>步骤一：创建业务词汇表单</h1><p>如果你是一位开发者，你或许会出席过一些软件设计会议，会议可能会涉及到创建新术语，以便于更好的软件设计交流。在创建该术语的同时可能会发生与该术语同义的情况，会议成员不可避免地讨论这些具有相同概念的术语，这会让人感到混乱。</p>
<p>这时，业务词汇表单就变得尤为重要，它能记录这些新的术语。在软件设计的每个阶段，你会不断碰到新的术语和概念。把这些术语保存起来非常重要，并且边学边存储，绝对有益无害。</p>
<p>业务词汇表单应该包含几个不同的列，分别是：“术语名称”、“语境”、“定义”。当你看到一个有趣的术语和短语时，可以更新该表单。该表单有可能包含大量的同义词，也有可能有对同一术语的不同定义解释。出现上述的情况，你需要结合上下文的语境进行分析使用。</p>
<h1 id="步骤二：了解应用程序"><a href="#步骤二：了解应用程序" class="headerlink" title="步骤二：了解应用程序"></a>步骤二：了解应用程序</h1><p>运行应用程序并且获知该程序提供的功能。如果你不知道该程序是做什么的，就无法在源代码中寻找有关信息。</p>
<h1 id="步骤三：浏览有效的类库文档"><a href="#步骤三：浏览有效的类库文档" class="headerlink" title="步骤三：浏览有效的类库文档"></a>步骤三：浏览有效的类库文档</h1><p>迄今为止，是不是任何的体系结构或设计类库文档的内容都是合理呢？这有待考量。类库文档是一个极好的资源。如果旧的体系架构已经历了数次修订，它就不再值得你花时间去阅读整个文档，不过，你可以大概浏览一下。如果你足够幸运，你可以在文档中遇到你所需的术语。</p>
<h1 id="步骤四：做假设"><a href="#步骤四：做假设" class="headerlink" title="步骤四：做假设"></a>步骤四：做假设</h1><p>几乎所有的应用程序中，开发者都会碰到如下情况：环境的配置、I18N（语言的国际化）、应用程序的文件格式、用户界面、应用程序的启动和关闭。针对这些情况，可以进行假设。开发者可以假设应用程序中的任何一段代码块，哪个代码块是应用程序的核心，这个才是学习的重点。</p>
<h1 id="步骤-五：定位第三方库文件"><a href="#步骤-五：定位第三方库文件" class="headerlink" title="步骤 五：定位第三方库文件"></a>步骤 五：定位第三方库文件</h1><p>代码库很有可能存在一些的依赖。如果检查到项目中包含第三方库文件，可以查看该库文件是如何与应用程序的功能联系起来的，某处的模块或组件是如何使用第三方库的。</p>
<h1 id="步骤六：分析代码"><a href="#步骤六：分析代码" class="headerlink" title="步骤六：分析代码"></a>步骤六：分析代码</h1><p>本部分列举几个选项来分析新的代码库：</p>
<h2 id="1、目录以及文件架构"><a href="#1、目录以及文件架构" class="headerlink" title="1、目录以及文件架构"></a>1、目录以及文件架构</h2><p>可以把目录名中的一些术语添加到业务词汇表单中。文件架构可以提供一些基本的线索，如：前台代码及后台代码。它们可以分别放在独立的文件中。开发者会发现，凡具有特定功能的模块代码都被放在独立的文件夹中。按照这个线索，就知道如何进行查找了。</p>
<h2 id="2、功能文件的映射"><a href="#2、功能文件的映射" class="headerlink" title="2、功能文件的映射"></a>2、功能文件的映射</h2><p>在用户界面上写一些可执行的功能代码块。把重要的代码块放到一个单独的文件夹中，并对文件夹进行命名。这个文件夹有可能对团队中的其他人有用，他们可以把该功能应用到项目编程中。</p>
<h2 id="3、单元测试"><a href="#3、单元测试" class="headerlink" title="3、单元测试"></a>3、单元测试</h2><p>如果采用单元测试，开发者可能会用到第三方框架。你可以用第三方框架来辅助测试。即使没有找到合适的框架，仍然可以来做单元测试。当然，你也可以不采用单元测试，但我依然推荐你用，因为有助于你对源代码中组件的理解。</p>
<h2 id="4、注释"><a href="#4、注释" class="headerlink" title="4、注释"></a>4、注释</h2><p>源代码中可能包含一些注释，有的注释对开发人员很有帮助，有的会让人有所误导或有的注释可能过期了。如果你觉得注释有问题，你可以通过调试器追踪有关代码，了解相关代码的意思。如果你发现错误的注释，修改或删除它们。</p>
<h2 id="5、可视化工具"><a href="#5、可视化工具" class="headerlink" title="5、可视化工具"></a>5、可视化工具</h2><p>在新的代码库中使用语言代码分析工具。如：ObjectAid是一个极好的Java代码分析工具。这是 Eclipse IDE中的一个插件。你可以创建对象来协助类图，把java文件拉到类图中，就自动画出类图。</p>
<h2 id="6、设置断点"><a href="#6、设置断点" class="headerlink" title="6、设置断点"></a>6、设置断点</h2><p>使用调试器，设置一些断点并运行查看。这是第一次学习新的代码基础。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>上述的分析过程采用自上而下的方法，能够更好的帮助开发者学习新的代码库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习新的代码库是一项艰巨的任务。如果你不能和创建该库的研发人员进行交流，自己研究该库是一个很复杂的过程。本文给出六个步骤指引开发者学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码学习 架构师之路" scheme="https://github.com/efbiz/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>分布式定时任务调度系统技术选型</title>
    <link href="https://github.com/efbiz/2017/08/15/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    <id>https://github.com/efbiz/2017/08/15/分布式定时任务方案技术选型/</id>
    <published>2017-08-15T00:57:41.000Z</published>
    <updated>2017-08-15T08:00:18.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我们先思考下面几个业务场景的解决方案"><a href="#我们先思考下面几个业务场景的解决方案" class="headerlink" title="我们先思考下面几个业务场景的解决方案:"></a>我们先思考下面几个业务场景的解决方案:</h1><ul>
<li>支付系统每天凌晨1点跑批，进行一天清算，每月1号进行上个月清算</li>
<li>电商整点抢购，商品价格8点整开始优惠</li>
<li>12306购票系统，超过30分钟没有成功支付订单的，进行回收处理</li>
<li>商品成功发货后，需要向客户发送短信提醒</li>
</ul>
<blockquote>
<p>类似的业务场景非常多，我们怎么解决？</p>
</blockquote>
<a id="more"></a>
<h1 id="为什么我们需要定时任务"><a href="#为什么我们需要定时任务" class="headerlink" title="为什么我们需要定时任务"></a>为什么我们需要定时任务</h1><p>很多业务场景需要我们某一特定的时刻去做某件任务，定时任务解决的就是这种业务场景。一般来说，系统可以使用消息传递代替部分定时任务，两者有很多相似之处，可以相互替换场景。如，上面发货成功发短信通知客户的业务场景，我们可以在发货成功后发送MQ消息到队列，然后去消费mq消息，发送短信。<br>但在某些场景下不能互换：</p>
<blockquote>
<p>a)时间驱动/事件驱动：内部系统一般可以通过时间来驱动，但涉及到外部系统，则只能使用时间驱动。如怕取外部网站价格，每小时爬一次<br>b)批量处理/逐条处理：批量处理堆积的数据更加高效，在不需要实时性的情况下比消息中间件更有优势。而且有的业务逻辑只能批量处理。如移动每个月结算我们的话费<br>c)实时性/非实时性：消息中间件能够做到实时处理数据，但是有些情况下并不需要实时，比如：vip升级<br>d)系统内部/系统解耦：定时任务调度一般是在系统内部，而消息中间件可用于两个系统间</p>
</blockquote>
<h1 id="java有哪些定时任务的框架"><a href="#java有哪些定时任务的框架" class="headerlink" title="java有哪些定时任务的框架"></a>java有哪些定时任务的框架</h1><h2 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h2><ul>
<li>timer：是一个定时器类，通过该类可以为指定的定时任务进行配置。TimerTask类是一个定时任务类，该类实现了Runnable接口，缺点异常未检查会中止线程</li>
<li>ScheduledExecutorService：相对延迟或者周期作为定时任务调度，缺点没有绝对的日期或者时间</li>
<li>spring定时框架：配置简单功能较多，如果系统使用单机的话可以优先考虑spring定时器</li>
</ul>
<h2 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h2><ul>
<li>Quartz：Java事实上的定时任务标准。但Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能</li>
<li>TBSchedule：阿里早期开源的分布式任务调度系统。代码略陈旧，使用timer而非线程池执行任务调度。众所周知，timer在处理异常状况时是有缺陷的。而且TBSchedule作业类型较为单一，只能是获取/处理数据一种模式。还有就是文档缺失比较严重</li>
<li>elastic-job：当当开发的弹性分布式任务调度系统，功能丰富强大，采用zookeeper实现分布式协调，实现任务高可用以及分片，目前是版本2.15，并且可以支持云开发</li>
<li>Saturn：是唯品会自主研发的分布式的定时任务的调度平台，基于当当的elastic-job 版本1开发，并且可以很好的部署到docker容器上。</li>
<li>xxl-job: 是大众点评员工徐雪里于2015年发布的分布式任务调度平台，是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。</li>
</ul>
<h1 id="分布式任务调度系统对比"><a href="#分布式任务调度系统对比" class="headerlink" title="分布式任务调度系统对比"></a>分布式任务调度系统对比</h1><blockquote>
<p>参与对比的可选系统方案： elastic——job （以下简称E-Job）与 xxx-job(以下简称X-Job)</p>
</blockquote>
<h2 id="项目背景及社区力量"><a href="#项目背景及社区力量" class="headerlink" title="项目背景及社区力量"></a>项目背景及社区力量</h2><p><em>X-Job</em>　：　大众点评公司下员工许雪里、贡献者 3人;　github有2470star、1015fork　|　QQ讨论群6个　|　有登记在使用的超过40家公司　|　文档齐全<br><em>E-Job</em>　：　当当网开源，贡献者17人;　github有2524star、1015fork　|　QQ讨论群１个、源码讨论群１个　|　有登记在使用的超过50家公司　|　文档齐全　｜　有明确的发展计划</p>
<h2 id="支持集群部署"><a href="#支持集群部署" class="headerlink" title="支持集群部署"></a>支持集群部署</h2><p><em>X-Job</em>　：　集群部署唯一要求为：保证每个集群节点配置（db和登陆账号等）保持一致。调度中心通过db配置区分不同集群。</p>
<blockquote>
<p>执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。集群部署唯一要求为：保证集群中每个执行器的配置项 “xxl.job.admin.addresses/调度中心地址” 保持一致，执行器根据该配置进行执行器自动注册等操作。</p>
</blockquote>
<p><em>E-Job</em>　：　重写Quartz基于数据库的分布式功能，改用Zookeeper实现注册中心</p>
<blockquote>
<p>作业注册中心： 基于Zookeeper和其客户端Curator实现的全局作业注册控制中心。用于注册，控制和协调分布式作业执行。</p>
</blockquote>
<h2 id="多节点部署时任务不能重复执行"><a href="#多节点部署时任务不能重复执行" class="headerlink" title="多节点部署时任务不能重复执行"></a>多节点部署时任务不能重复执行</h2><p><em>X-Job</em>　：　使用Quartz基于数据库的分布式功能<br><em>E-Job</em>　 ：　将任务拆分为n个任务项后，各个服务器分别执行各自分配到的任务项。一旦有新的服务器加入集群，或现有服务器下线，elastic-job将在保留本次任务执行不变的情况下，下次任务开始前触发任务重分片。</p>
<h2 id="日志可追溯"><a href="#日志可追溯" class="headerlink" title="日志可追溯"></a>日志可追溯</h2><p><em>X-Job</em>　：　支持，有日志查询界面<br><em>E-Job</em>　：　可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job目前提供了基于关系型数据库两种事件订阅方式记录事件。</p>
<h2 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h2><p><em>X-Job</em>　：　调度失败时，将会触发失败报警，如发送报警邮件。</p>
<blockquote>
<p>任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔</p>
</blockquote>
<p><em>E-Job</em>　：　通过事件订阅方式可自行实现</p>
<blockquote>
<p>作业运行状态监控、监听作业服务器存活、监听近期数据处理成功、数据流类型作业（可通过监听近期数据处理成功数判断作业流量是否正常,如果小于作业正常处理的阀值，可选择报警。）、监听近期数据处理失败（可通过监听近期数据处理失败数判断作业处理结果，如果大于0，可选择报警。）</p>
</blockquote>
<h2 id="弹性扩容缩容"><a href="#弹性扩容缩容" class="headerlink" title="弹性扩容缩容"></a>弹性扩容缩容</h2><p><em>X-Job</em>　：　使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力<br><em>E-Job</em>　：　通过zk实现各服务的注册、控制及协调</p>
<h2 id="支持并行调度"><a href="#支持并行调度" class="headerlink" title="支持并行调度"></a>支持并行调度</h2><p><em>X-Job</em>　：　调度系统多线程（默认10个线程）触发调度运行，确保调度精确执行，不被堵塞。<br><em>E-Job</em>　：　采用任务分片方式实现。将一个任务拆分为n个独立的任务项，由分布式的服务器并行执行各自分配到的分片项。</p>
<h2 id="高可用策略"><a href="#高可用策略" class="headerlink" title="高可用策略"></a>高可用策略</h2><p><em>X-Job</em>　：　“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；<br><em>E-Job</em>　：　调度器的高可用是通过运行几个指向同一个ZooKeeper集群的Elastic-Job-Cloud-Scheduler实例来实现的。ZooKeeper用于在当前主Elastic-Job-Cloud-Scheduler实例失败的情况下执行领导者选举。通过至少两个调度器实例来构成集群，集群中只有一个调度器实例提供服务，其他实例处于”待命”状态。当该实例失败时，集群会选举剩余实例中的一个来继续提供服务。</p>
<h2 id="失败处理策略"><a href="#失败处理策略" class="headerlink" title="失败处理策略"></a>失败处理策略</h2><p><em>X-Job</em>　：　调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；<br><em>E-Job</em>　：　弹性扩容缩容在下次作业运行前重分片，但本次作业执行的过程中，下线的服务器所分配的作业将不会重新被分配。失效转移功能可以在本次作业运行中用空闲服务器抓取孤儿作业分片执行。同样失效转移功能也会牺牲部分性能。</p>
<h2 id="动态分片策略"><a href="#动态分片策略" class="headerlink" title="动态分片策略"></a>动态分片策略</h2><p><em>X-Job</em>　：　分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。</p>
<blockquote>
<p>执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务；</p>
</blockquote>
<p><em>E-Job</em>　：　支持多种分片策略，可自定义分片策略</p>
<blockquote>
<p>默认包含三种分片策略： 基于平均分配算法的分片策略、 作业名的哈希值奇偶数决定IP升降序算法的分片策略、根据作业名的哈希值对Job实例列表进行轮转的分片策略，支持自定义分片策略</p>
<p>elastic-job的分片是通过zookeeper来实现的。分片的分片由主节点分配，如下三种情况都会触发主节点上的分片算法执行：<br>a、新的Job实例加入集群<br>b、现有的Job实例下线（如果下线的是leader节点，那么先选举然后触发分片算法的执行）<br>c、主节点选举”</p>
</blockquote>
<h2 id="和quartz框架对比"><a href="#和quartz框架对比" class="headerlink" title="和quartz框架对比"></a>和quartz框架对比</h2><ul>
<li>调用API的的方式操作任务，不人性化； </li>
<li>需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。 </li>
<li>调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务；</li>
<li>Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。</li>
</ul>
<h1 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h1><p><img src="MicroServiceJob.png" alt=""> </p>
<h1 id="总结和结论"><a href="#总结和结论" class="headerlink" title="总结和结论"></a>总结和结论</h1><p>  共同点： E-Job和X-job都有广泛的用户基础和完整的技术文档，都能满足定时任务的基本功能需求。<br>  不同点<br>  X-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用<br>  E-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用</p>
<h1 id="附-定时任务的其他方案"><a href="#附-定时任务的其他方案" class="headerlink" title="附 定时任务的其他方案"></a>附 定时任务的其他方案</h1><p>发货后超过10天未收货时系统自动确认收货的多种实现方式</p>
<blockquote>
<p>每天定时半夜筛选第二天 可以自动确认收货的订单,然后第二天 每10分钟 执行一次确认收货 开销不会太大吧 时间也相对精确</p>
<p>自动确认收货这个状态如果仅仅是让客户端看的话，等用户下一次上线的时间，做一次运算就可以了。</p>
<p>延迟和定时消息投递<br>ActiveMQ提供了一种broker端消息定时调度机制。适用于：1、不希望消息马上被broker投递出去，而是想要消息60秒以后发给消费者，2、想让消息没隔一定时间投递一次，一共投递指定的次数<br>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter。利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我们先思考下面几个业务场景的解决方案&quot;&gt;&lt;a href=&quot;#我们先思考下面几个业务场景的解决方案&quot; class=&quot;headerlink&quot; title=&quot;我们先思考下面几个业务场景的解决方案:&quot;&gt;&lt;/a&gt;我们先思考下面几个业务场景的解决方案:&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;支付系统每天凌晨1点跑批，进行一天清算，每月1号进行上个月清算&lt;/li&gt;
&lt;li&gt;电商整点抢购，商品价格8点整开始优惠&lt;/li&gt;
&lt;li&gt;12306购票系统，超过30分钟没有成功支付订单的，进行回收处理&lt;/li&gt;
&lt;li&gt;商品成功发货后，需要向客户发送短信提醒&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;类似的业务场景非常多，我们怎么解决？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="微服务" scheme="https://github.com/efbiz/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="定时任务" scheme="https://github.com/efbiz/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="分布式架构" scheme="https://github.com/efbiz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="https://github.com/efbiz/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="定时任务" scheme="https://github.com/efbiz/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java设计6大原则</title>
    <link href="https://github.com/efbiz/2017/08/11/Java%E8%AE%BE%E8%AE%A16%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://github.com/efbiz/2017/08/11/Java设计6大原则/</id>
    <published>2017-08-11T08:57:38.000Z</published>
    <updated>2017-08-16T00:51:24.838Z</updated>
    
    <content type="html"><![CDATA[<p>  所谓无招胜有招，练一门功夫分为内功和外功。外功好比招式，就是所谓的23种设计模式。而内功呢，就是心法，那就是这6种法则。光会外功那是花拳绣腿，内功修为才是境界。如此众多的设计模式，学完2遍，3遍可能也会忘的只记得单例和工厂模式。但是只要原则记住，在以后的设计中，有意无意就会用的设计模式的精髓。<br><a id="more"></a><br>一 ： 类单一职责原则：</p>
<blockquote>
<p>一个类只有一个引起这个类变化的原因。即一个类只完成一个功能，如果做不到一个类只完成一个功能，最少要保证一个方法只完成一个功能。</p>
</blockquote>
<p>二：依赖倒置原则：</p>
<blockquote>
<p>高层组件应该依赖抽象而不依赖具体，即面向接口编程，一般依赖的成员变量或者参数都应该是抽象的不应该是具体的。</p>
</blockquote>
<p>三：里氏代换原则：</p>
<blockquote>
<p>凡是父类出现的地方都可以用子类代替并且原功能没有发生变化，子类不应该覆盖父类的非抽象方法。</p>
</blockquote>
<p>四：迪米特法则：</p>
<blockquote>
<p>一个类要尽量的封装自己，一个类只与自己的朋友类打交道一般朋友类是成员变量或者参数，非朋友类一般都是局部变量</p>
</blockquote>
<p>五：接口隔离原则：</p>
<blockquote>
<p>一个接口完成的功能尽可能的单一，不要让一个接口承担过多的责任。</p>
</blockquote>
<p>六：开闭原则：</p>
<blockquote>
<p>对扩展开放，对修改闭合</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  所谓无招胜有招，练一门功夫分为内功和外功。外功好比招式，就是所谓的23种设计模式。而内功呢，就是心法，那就是这6种法则。光会外功那是花拳绣腿，内功修为才是境界。如此众多的设计模式，学完2遍，3遍可能也会忘的只记得单例和工厂模式。但是只要原则记住，在以后的设计中，有意无意就会用的设计模式的精髓。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java设计" scheme="https://github.com/efbiz/tags/Java%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计原理</title>
    <link href="https://github.com/efbiz/2017/08/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://github.com/efbiz/2017/08/06/领域驱动设计原理/</id>
    <published>2017-08-06T12:57:41.000Z</published>
    <updated>2017-08-24T06:14:47.290Z</updated>
    
    <content type="html"><![CDATA[<p>使用领域驱动设计的业务价值<br>1、你获得了一个非常有用的领域模型<br>2、你的业务得到了更准确的定义和理解<br>3、领域专家可以为软件设计做出贡献<br>4、更好的用户体验<br>5、清晰的模型边界<br>6、更好的企业架构<br>7、敏捷、迭代式和持续建模<br>8、使用战略和战术新工具</p>
<a id="more"></a>
<h1 id="领域驱动设计参考项目推荐"><a href="#领域驱动设计参考项目推荐" class="headerlink" title="领域驱动设计参考项目推荐"></a>领域驱动设计参考项目推荐</h1><p>1.IDDD_Samples<br>实现领域驱动设计作者VaughnVernon 所做的四种不同实现<br><a href="https://github.com/VaughnVernon/IDDD_Samples">https://github.com/VaughnVernon/IDDD_Samples</a></p>
<p>2.dddsample-core<br>领域驱动设计(Domain Driven Design)的官方参考架构，该架构分成了Interfaces、Applications和Domain三层以及包含各类基础设施的Infrastructure。<br><a href="https://github.com/citerus/dddsample-core">https://github.com/citerus/dddsample-core</a></p>
<p>3.Axon-trader<br>基于命令查询职责分离(CQRS)模式的一种领域驱动实现<br><a href="https://github.com/AxonFramework/Axon-trader，依赖框架">https://github.com/AxonFramework/Axon-trader，依赖框架</a> <a href="https://github.com/AxonFramework/AxonFramework">https://github.com/AxonFramework/AxonFramework</a><br>其中有整合disruptor的实现的命令总线和自身的命令总线。<br>Disruptor是一个高性能的异步处理框架，或者可以认为是最快的消息框架(轻量的JMS)，也可以认为是一个观察者模式实现，或者事件-监听模式的实现，直接称disruptor模式。disruptor最大特点是高性能，其LMAX架构可以获得每秒6百万订单，用1微秒的延迟获得吞吐量为100K+。</p>
<h1 id="《领域驱动设计模式、原理与实践》-整理思维导图"><a href="#《领域驱动设计模式、原理与实践》-整理思维导图" class="headerlink" title="《领域驱动设计模式、原理与实践》 整理思维导图"></a>《领域驱动设计模式、原理与实践》 整理思维导图</h1><p><img src="领域驱动设计模式、原理与实践.png" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用领域驱动设计的业务价值&lt;br&gt;1、你获得了一个非常有用的领域模型&lt;br&gt;2、你的业务得到了更准确的定义和理解&lt;br&gt;3、领域专家可以为软件设计做出贡献&lt;br&gt;4、更好的用户体验&lt;br&gt;5、清晰的模型边界&lt;br&gt;6、更好的企业架构&lt;br&gt;7、敏捷、迭代式和持续建模&lt;br&gt;8、使用战略和战术新工具&lt;/p&gt;
    
    </summary>
    
      <category term="领域驱动设计" scheme="https://github.com/efbiz/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="模式、原理与实践" scheme="https://github.com/efbiz/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="领域驱动设计" scheme="https://github.com/efbiz/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="领域驱动设计模式" scheme="https://github.com/efbiz/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="领域驱动设计原理与实践" scheme="https://github.com/efbiz/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
</feed>
